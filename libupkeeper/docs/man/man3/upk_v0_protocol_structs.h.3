.TH "upkeeper/upk_v0_protocol_structs.h" 3 "30 Jun 2011" "Version 1" "libupkeeper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
upkeeper/upk_v0_protocol_structs.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBUPK_V0_REQ_SEQ_START_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REQ_SEQ_END_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_ACTION_REQ_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_SIGNAL_REQ_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_LIST_REQ_T_FIELDS\fP   \fBupk_req_msgtype_t\fP       msgtype"
.br
.ti -1c
.RI "#define \fBUPK_V0_STATUS_REQ_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_SUBSCR_REQ_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_UNSUBS_REQ_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_DISCON_REQ_T_FIELDS\fP   \fBupk_req_msgtype_t\fP       msgtype"
.br
.ti -1c
.RI "#define \fBUPK_V0_REPL_SEQ_START_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REPL_SEQ_END_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_RESULT_REPL_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_LISTING_REPL_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_SVCINFO_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_SVCINFO_REPL_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_ACK_REPL_T_FIELDS\fP   \fBupk_repl_msgtype_t\fP      msgtype"
.br
.ti -1c
.RI "#define \fBUPK_V0_ERROR_REPL_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_PUBLICATION_T_FIELDS\fP   \fBupk_pub_msgtype_t\fP       msgtype"
.br
.ti -1c
.RI "#define \fBUPK_V0_CANCELATION_T_FIELDS\fP   \fBupk_pub_msgtype_t\fP       msgtype"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define UPK_V0_ACK_REPL_T_FIELDS   \fBupk_repl_msgtype_t\fP      msgtype"
.PP
.SS "#define UPK_V0_ACTION_REQ_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_req_msgtype_t       msgtype; \
    uint32_t                svc_id_len; \
    char                   *svc_id; \
    uint32_t                action_len; \
    char                   *action
.fi
.SS "#define UPK_V0_CANCELATION_T_FIELDS   \fBupk_pub_msgtype_t\fP       msgtype"
.PP
.SS "#define UPK_V0_DISCON_REQ_T_FIELDS   \fBupk_req_msgtype_t\fP       msgtype"
.PP
.SS "#define UPK_V0_ERROR_REPL_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_repl_msgtype_t      msgtype; \
    upk_errlevel_t          errlevel; \
    uint32_t                msg_len; \
    char                   *msg; \
    uint32_t                svc_id_len; \
    char                   *svc_id
.fi
.SS "#define UPK_V0_LIST_REQ_T_FIELDS   \fBupk_req_msgtype_t\fP       msgtype"
.PP
.SS "#define UPK_V0_LISTING_REPL_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_repl_msgtype_t      msgtype; \
    uint32_t                svc_id_len; \
    char                   *svc_id
.fi
.SS "#define UPK_V0_PUBLICATION_T_FIELDS   \fBupk_pub_msgtype_t\fP       msgtype"
.PP
.SS "#define UPK_V0_REPL_SEQ_END_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_repl_msgtype_t      msgtype; \
    bool                    commit
.fi
.SS "#define UPK_V0_REPL_SEQ_START_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_repl_msgtype_t      msgtype; \
    upk_repl_msgtype_t      msg_seq_type; \
    uint32_t                msg_seq_count
.fi
.SS "#define UPK_V0_REQ_SEQ_END_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_req_msgtype_t       msgtype; \
    bool                    commit                         /* if false, the preceding sequence of requests since the */ \
.fi
.SS "#define UPK_V0_REQ_SEQ_START_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_req_msgtype_t       msgtype; \
    upk_req_msgtype_t       msg_seq_type; \
    uint32_t                msg_seq_count
.fi
.SS "#define UPK_V0_RESULT_REPL_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_repl_msgtype_t      msgtype; \
    bool                    successful; \
    uint32_t                msg_len; \
    char                   *msg
.fi
.SS "#define UPK_V0_SIGNAL_REQ_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_req_msgtype_t       msgtype; \
    upk_signal_t       signal; \
    bool                    signal_sid; \
    bool                    signal_pgrp; \
    uint32_t                svc_id_len; \
    char                   *svc_id
.fi
.SS "#define UPK_V0_STATUS_REQ_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_req_msgtype_t       msgtype; \
    uint32_t                svc_id_len; \
    char                   *svc_id
.fi
.SS "#define UPK_V0_SUBSCR_REQ_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_req_msgtype_t       msgtype; \
    bool                    all_svcs;                     /* send a req with all=true to subscribe to everything in */ \
                                                          /* one shot; svc_id will be ignored, and should have len 0 */ \
    uint32_t                svc_id_len; \
    char                   *svc_id
.fi
.SS "#define UPK_V0_SVCINFO_REPL_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_repl_msgtype_t      msgtype; \
    uint32_t                svcinfo_len;                   /* sizeof struct can be arch dependant; immaterial on unix */ \
                                                           /* domain socket; but to keep this network safe, I'm going */ \
                                                           /* to go ahead and serialize it the same as everything else */ \
    v0_svcinfo_t            svcinfo; \
    uint32_t                svc_id_len; \
    char                   *svc_id
.fi
.SS "#define UPK_V0_SVCINFO_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
uint32_t                last_action_time; \
    uint32_t                last_action_status; \
    uint32_t                last_action_name_len; \
    char                    last_action_name[UPK_MAX_STRING_LEN]; \
    uint32_t                last_signal_time; \
    uint32_t                last_signal_status; \
    upk_signal_t       last_signal_name; \
    uint32_t                buddy_pid; \
    uint32_t                proc_pid; \
    upk_state_t             current_state; \
    upk_state_t             prior_state
.fi
.SS "#define UPK_V0_UNSUBS_REQ_T_FIELDS"
.PP
\fBValue:\fP
.PP
.nf
upk_req_msgtype_t       msgtype; \
    bool                    all_svcs; \
    uint32_t                svc_id_len; \
    char                   *svc_id
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for libupkeeper from the source code.
