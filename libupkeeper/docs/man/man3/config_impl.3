.TH "Config_impl" 3 "30 Jun 2011" "Version 1" "libupkeeper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Config_impl \- 
.SS "Modules"

.in +1c
.ti -1c
.RI "\fBServices\fP"
.br
.ti -1c
.RI "\fBController\fP"
.br
.ti -1c
.RI "\fBFunctions\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fB_stringify\fP(A)   #A"
.br
.ti -1c
.RI "#define \fBstringify\fP(A)   _stringify(A)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBupk_ctrlconf_string_handler\fP (char *key, char *string)"
.br
.ti -1c
.RI "static void \fBupk_svcconf_bool_handler\fP (char *key, _Bool val)"
.br
.ti -1c
.RI "static void \fBupk_svcconf_string_handler\fP (char *key, char *string)"
.br
.ti -1c
.RI "static void \fBupk_ctrl_service_pop_handler\fP (char *key, void *obj)"
.br
.ti -1c
.RI "static void \fBupk_service_parse_handlers\fP (void)"
.br
.ti -1c
.RI "static void \fBupk_ctrlconf_object_handler\fP (char *key, void *jobj)"
.br
.ti -1c
.RI "static void \fBupk_ctrl_config_parse_handlers\fP (void *buf)"
.br
.ti -1c
.RI "static char * \fBupk_config_loadfile\fP (const char *filename)"
.br
.ti -1c
.RI "static void \fBupk_ctrl_config_pack\fP (\fBupk_controller_config_t\fP *cfg, const char *json_string)"
.br
.ti -1c
.RI "static void \fBupk_svcconf_bool_handler\fP (char *key, bool val)"
.br
.ti -1c
.RI "static void \fBupk_svcconf_int_handler\fP (char *key, int val)"
.br
.ti -1c
.RI "static void \fBupk_svcconf_double_handler\fP (char *key, double val)"
.br
.ti -1c
.RI "void \fBupk_load_config\fP (void)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static void * \fB_upk_ctrl_service_pop_handler_data_buf\fP"
.br
.ti -1c
.RI "const char \fBupk_ctrl_configuration_file\fP [UPK_MAX_PATH_LEN] = stringify(CONF_SYSCONFDIR) '/upkeeper.conf'"
.br
.ti -1c
.RI "const char \fBupk_default_configuration_vec\fP []"
.br
.ti -1c
.RI "\fBupk_controller_config_t\fP \fBupk_default_configuration\fP"
.br
.ti -1c
.RI "\fBupk_controller_config_t\fP \fBupk_runtime_configuration\fP"
.br
.ti -1c
.RI "char \fB_upk_svc_desc::Name\fP [UPK_MAX_STRING_LEN]"
.br
.ti -1c
.RI "char \fB_upk_svc_desc::Provides\fP [UPK_MAX_STRING_LEN]"
.br
.ti -1c
.RI "\fBupk_uuid_t\fP \fB_upk_svc_desc::UUID\fP"
.br
.ti -1c
.RI "char \fB_upk_svc_desc::ShortDescription\fP [UPK_MAX_STRING_LEN]"
.br
.ti -1c
.RI "char * \fB_upk_svc_desc::LongDescription\fP"
.br
.ti -1c
.RI "\fBupk_svclist_t\fP * \fB_upk_svc_desc::Prerequisites\fP"
.br
.ti -1c
.RI "int32_t \fB_upk_svc_desc::StartPriority\fP"
.br
.ti -1c
.RI "int32_t \fB_upk_svc_desc::BuddyShutdownTimeout\fP"
.br
.ti -1c
.RI "int32_t \fB_upk_svc_desc::KillTimeout\fP"
.br
.ti -1c
.RI "int32_t \fB_upk_svc_desc::UserMaxRestarts\fP"
.br
.ti -1c
.RI "int32_t \fB_upk_svc_desc::UserRestartWindow\fP"
.br
.ti -1c
.RI "int32_t \fB_upk_svc_desc::UserRateLimit\fP"
.br
.ti -1c
.RI "bool \fB_upk_svc_desc::RandomizeRateLimit\fP"
.br
.ti -1c
.RI "uid_t \fB_upk_svc_desc::SetUID\fP"
.br
.ti -1c
.RI "gid_t \fB_upk_svc_desc::SetGID\fP"
.br
.ti -1c
.RI "size_t \fB_upk_svc_desc::RingbufferSize\fP"
.br
.ti -1c
.RI "int32_t \fB_upk_svc_desc::ReconnectRetries\fP"
.br
.ti -1c
.RI "char \fB_upk_svc_desc::ExecStart\fP [UPK_MAX_PATH_LEN]"
.br
.ti -1c
.RI "char * \fB_upk_svc_desc::StartScript\fP"
.br
.ti -1c
.RI "char * \fB_upk_svc_desc::StopScript\fP"
.br
.ti -1c
.RI "char * \fB_upk_svc_desc::ReloadScript\fP"
.br
.ti -1c
.RI "\fBupk_cust_actscr_list_t\fP * \fB_upk_svc_desc::custom_action_scripts\fP"
.br
.ti -1c
.RI "char * \fB_upk_svc_desc::PipeStdoutScript\fP"
.br
.ti -1c
.RI "char * \fB_upk_svc_desc::PipeStderrScript\fP"
.br
.ti -1c
.RI "char \fB_upk_svc_desc::RedirectStdout\fP [UPK_MAX_PATH_LEN]"
.br
.ti -1c
.RI "char \fB_upk_svc_desc::RedirectStderr\fP [UPK_MAX_PATH_LEN]"
.br
.ti -1c
.RI "\fBupk_state_t\fP \fB_upk_svc_desc::InitialState\fP"
.br
.ti -1c
.RI "bool \fB_upk_svc_desc::UnconfigureOnFileRemoval\fP"
.br
.ti -1c
.RI "bool \fB_upk_svc_desc::PreferBuddyStateForStopped\fP"
.br
.ti -1c
.RI "bool \fB_upk_svc_desc::PreferBuddyStateForRunning\fP"
.br
.ti -1c
.RI "\fBupk_svc_desc_t\fP * \fB_upk_svc_desc::next\fP"
.br
.ti -1c
.RI "char \fB_upk_controller_config::SvcConfigPath\fP [UPK_MAX_PATH_LEN]"
.br
.ti -1c
.RI "char \fB_upk_controller_config::SvcRunPath\fP [UPK_MAX_PATH_LEN]"
.br
.ti -1c
.RI "char \fB_upk_controller_config::controller_socket\fP [UPK_MAX_PATH_LEN]"
.br
.ti -1c
.RI "char \fB_upk_controller_config::controller_buddy_sock\fP [UPK_MAX_PATH_LEN]"
.br
.ti -1c
.RI "\fBupk_svc_desc_t\fP \fB_upk_controller_config::ServiceDefaults\fP"
.br
.ti -1c
.RI "\fBupk_svc_desc_t\fP * \fB_upk_controller_config::svclist\fP"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define _stringify(A)   #A"
.PP
.SS "#define stringify(A)   _stringify(A)"
.PP
.SH "Function Documentation"
.PP 
.SS "static char * upk_config_loadfile (const char * filename)\fC [static]\fP"
.PP
.SS "static void upk_ctrl_config_pack (\fBupk_controller_config_t\fP * cfg, const char * json_string)\fC [static]\fP"
.PP
.SS "static void upk_ctrl_config_parse_handlers (void * buf)\fC [static]\fP"
.PP
.SS "static void upk_ctrl_service_pop_handler (char * key, void * obj)\fC [static]\fP"
.PP
.SS "static void upk_ctrlconf_object_handler (char * key, void * jobj)\fC [static]\fP"
.PP
.SS "static void upk_ctrlconf_string_handler (char * key, char * string)\fC [static]\fP"
.PP
.SS "void upk_load_config (void)"
.PP
.SS "static void upk_service_parse_handlers (void)\fC [inline, static]\fP"
.PP
.SS "static void upk_svcconf_bool_handler (char * key, bool val)\fC [static]\fP"
.PP
.SS "static void upk_svcconf_bool_handler (char * key, _Bool val)\fC [static]\fP"
.PP
.SS "static void upk_svcconf_double_handler (char * key, double val)\fC [static]\fP"
.PP
.SS "static void upk_svcconf_int_handler (char * key, int val)\fC [static]\fP"
.PP
.SS "static void upk_svcconf_string_handler (char * key, char * string)\fC [static]\fP"
.PP
.SH "Variable Documentation"
.PP 
.SS "void* \fB_upk_ctrl_service_pop_handler_data_buf\fP\fC [static]\fP"
.PP
.SS "int32_t \fB_upk_svc_desc::BuddyShutdownTimeout\fP\fC [inherited]\fP"
.PP
when a service is stopped; how many seconds to wait before shutting the buddy down to conserve resources. a value < 0 means to leave the buddy running indefinately 
.SS "char \fB_upk_controller_config::controller_buddy_sock\fP[UPK_MAX_PATH_LEN]\fC [inherited]\fP"
.PP
path to buddy socket; used internally 
.SS "char \fB_upk_controller_config::controller_socket\fP[UPK_MAX_PATH_LEN]\fC [inherited]\fP"
.PP
path to the controller socket, used internally 
.SS "\fBupk_cust_actscr_list_t\fP* \fB_upk_svc_desc::custom_action_scripts\fP\fC [inherited]\fP"
.PP
linked list of custom actions 
.SS "char \fB_upk_svc_desc::ExecStart\fP[UPK_MAX_PATH_LEN]\fC [inherited]\fP"
.PP
executable to exec for start. see 'StartScript' 
.SS "\fBupk_state_t\fP \fB_upk_svc_desc::InitialState\fP\fC [inherited]\fP"
.PP
state the service should be set to initially; this is used only when a service is first configured 
.SS "int32_t \fB_upk_svc_desc::KillTimeout\fP\fC [inherited]\fP"
.PP
how long to wait for a service to stop before issuing TERM and, if necessary, KILL signals to bring it down. A negative value means to wait indefiniately for a stopped process to terminate 
.SS "char* \fB_upk_svc_desc::LongDescription\fP\fC [inherited]\fP"
.PP
a brief description of the service an arbitrary length description of the service 
.SS "char \fB_upk_svc_desc::Name\fP[UPK_MAX_STRING_LEN]\fC [inherited]\fP"
.PP
service name. if pkg is used, the concatination of <pkg>::<name> must be unique; otherwise this name must be unique 
.SS "\fBupk_svc_desc_t\fP* \fB_upk_svc_desc::next\fP\fC [inherited]\fP"
.PP
for use in lists 
.SS "char* \fB_upk_svc_desc::PipeStderrScript\fP\fC [inherited]\fP"
.PP
optional script to pipe stderr to. for instance: 'exec logger -p local0.warn' 
.SS "char* \fB_upk_svc_desc::PipeStdoutScript\fP\fC [inherited]\fP"
.PP
optional script to pipe stdout to. for instance: 'exec logger -p local0.notice' 
.SS "bool \fB_upk_svc_desc::PreferBuddyStateForRunning\fP\fC [inherited]\fP"
.PP
if the controller starts/restarts, and buddy has a service state set to 'running', but controller's data-store believes the service should be stopped, prefer buddy's world view, and update the data-store to reflect the running state (the default is to trust the data-store, which would cause the service to be stopped 
.SS "bool \fB_upk_svc_desc::PreferBuddyStateForStopped\fP\fC [inherited]\fP"
.PP
if the controller starts/restartindent: Standard input:189: Error:Stmt nesting error. s, and buddy has a service state set to 'stopped', but controller's data-store believes the service should be running, prefer buddy's world view, and update the data-store to reflect the stopped state (the default is to trust the data-store; which would cause the service to be started 
.SS "\fBupk_svclist_t\fP* \fB_upk_svc_desc::Prerequisites\fP\fC [inherited]\fP"
.PP
A list of prerequisite services that must be started prior to this service; either by name, pkg-prefix, or by what they provide 
.SS "char \fB_upk_svc_desc::Provides\fP[UPK_MAX_STRING_LEN]\fC [inherited]\fP"
.PP
a string describing the function of this service. this can be used in prerequisite constraints upon other services. i.e. a prerequisite might be 'entropy-service', and any service providing 'entropy-service' would then satisfy that prerequisite [vaguely remeniscent of the debian 'alternatives' system] 
.SS "bool \fB_upk_svc_desc::RandomizeRateLimit\fP\fC [inherited]\fP"
.PP
a flag to enable/disable adding a randomized 'jitter' to the user_ratelimit 
.SS "int32_t \fB_upk_svc_desc::ReconnectRetries\fP\fC [inherited]\fP"
.PP
number of times to retry connections to the controler when emergent actions occur in the buddy; (-1 for indefinate) 
.SS "char \fB_upk_svc_desc::RedirectStderr\fP[UPK_MAX_PATH_LEN]\fC [inherited]\fP"
.PP
optional place to direct stderr. Note that if you pipe stderr elsewhere, this might never be written to, unless the thing you pipe to prints to stderr itself 
.SS "char \fB_upk_svc_desc::RedirectStdout\fP[UPK_MAX_PATH_LEN]\fC [inherited]\fP"
.PP
optional place to direct stdout. Note that if you pipe stdout elsewhere, this might never be written to, unless the thing you pipe to prints to stdout itself 
.SS "char* \fB_upk_svc_desc::ReloadScript\fP\fC [inherited]\fP"
.PP
replace the default reload script of 'exec kill -HUP $1'; argv[1] == pid of monitored process 
.SS "size_t \fB_upk_svc_desc::RingbufferSize\fP\fC [inherited]\fP"
.PP
size of the ringbuffer to maintain in the buddy 
.SS "\fBupk_svc_desc_t\fP \fB_upk_controller_config::ServiceDefaults\fP\fC [inherited]\fP"
.PP
default service configuration parameters; used whenever an individual service omits something 
.SS "gid_t \fB_upk_svc_desc::SetGID\fP\fC [inherited]\fP"
.PP
if controller and/or buddy is run euid root; which gid to run the service as 
.SS "uid_t \fB_upk_svc_desc::SetUID\fP\fC [inherited]\fP"
.PP
if controller and/or buddy is run euid root; which uid to run the service as 
.SS "char \fB_upk_svc_desc::ShortDescription\fP[UPK_MAX_STRING_LEN]\fC [inherited]\fP"
.PP
.SS "int32_t \fB_upk_svc_desc::StartPriority\fP\fC [inherited]\fP"
.PP
similar to prerequisites, provide a fixed numeric start priority to indicate service startup order 
.SS "char* \fB_upk_svc_desc::StartScript\fP\fC [inherited]\fP"
.PP
script to run to start the monitored process; repaces the default of exec <ExecStart> 
.SS "char* \fB_upk_svc_desc::StopScript\fP\fC [inherited]\fP"
.PP
replace the default stop script of 'exec kill $1'; argv[1] == pid of monitored process 
.SS "char \fB_upk_controller_config::SvcConfigPath\fP[UPK_MAX_PATH_LEN]\fC [inherited]\fP"
.PP
path to service configuration files 
.SS "\fBupk_svc_desc_t\fP* \fB_upk_controller_config::svclist\fP\fC [inherited]\fP"
.PP
head-pointer to list of service descriptions 
.SS "char \fB_upk_controller_config::SvcRunPath\fP[UPK_MAX_PATH_LEN]\fC [inherited]\fP"
.PP
path where buddy's will be created and run, usually ${statedir}/buddies 
.SS "bool \fB_upk_svc_desc::UnconfigureOnFileRemoval\fP\fC [inherited]\fP"
.PP
May be used by a package to instruct the controler to remove a configured service if the file defining that service ever disappears. possibly useful in packaging to cleanup the controller on package removal. The default behavior is to ignore file removal, and require explicit manual removal of configured services 
.SS "const char \fBupk_ctrl_configuration_file\fP[UPK_MAX_PATH_LEN] = stringify(CONF_SYSCONFDIR) '/upkeeper.conf'"
.PP
.SS "\fBupk_controller_config_t\fP \fBupk_default_configuration\fP"
.PP
.SS "const char \fBupk_default_configuration_vec\fP[]"
.PP
.SS "\fBupk_controller_config_t\fP \fBupk_runtime_configuration\fP"
.PP
.SS "int32_t \fB_upk_svc_desc::UserMaxRestarts\fP\fC [inherited]\fP"
.PP
user-defined max number of restarts within restart window 
.SS "int32_t \fB_upk_svc_desc::UserRateLimit\fP\fC [inherited]\fP"
.PP
duration, in seconds, to wait between respawn attempts 
.SS "int32_t \fB_upk_svc_desc::UserRestartWindow\fP\fC [inherited]\fP"
.PP
user-defined restart window, in seconds 
.SS "\fBupk_uuid_t\fP \fB_upk_svc_desc::UUID\fP\fC [inherited]\fP"
.PP
a uuid for a service; dynamically generated at service creation in most cases 
