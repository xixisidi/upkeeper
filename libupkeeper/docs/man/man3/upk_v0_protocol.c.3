.TH "upkeeper/upk_v0_protocol.c" 3 "30 Jun 2011" "Version 1" "libupkeeper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
upkeeper/upk_v0_protocol.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'upk_v0_protocol.h'\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBPROTOCOL_VERSION\fP   0"
.br
.ti -1c
.RI "#define \fBUPK_INIT_HELPER\fP(TYPE, MSGTYPE)"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_UINT32_EXPLICIT\fP(DEST, SRC)"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_UINT32\fP(MEMB)   UPK_HELPER_UINT32_EXPLICIT(UPK_DATA->MEMB, MEMB);"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_UINT16_EXPLICIT\fP(DEST, SRC)"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_UINT16\fP(MEMB)   UPK_HELPER_UINT16_EXPLICIT(UPK_DATA->MEMB, MEMB);"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_UINT8_EXPLICIT\fP(DEST, SRC)"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_UINT8\fP(MEMB)   UPK_HELPER_UINT8_EXPLICIT(UPK_DATA->MEMB, MEMB);"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_ENUM\fP(MEMB)   UPK_HELPER_UINT32(MEMB)"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_BOOL\fP(MEMB)   UPK_HELPER_UINT8(MEMB)"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_BUF\fP(DEST, SRC, LEN)"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_ANSISTRING\fP(DEST, SRC)"
.br
.ti -1c
.RI "#define \fBUPK_HELPER_STRING\fP(MEMB)"
.br
.ti -1c
.RI "#define \fBUPK_END_HELPER\fP(PKT_TYPE)   return upk_create_pkt(UPK_DATA, UPK_DATA_LEN, PKT_TYPE, PROTOCOL_VERSION)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(*) \fBfree_data_t\fP (void *)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBv0_free_error_repl\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_svcinfo_repl\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_listing_repl\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_result_repl\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_unsubs_req\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_subscr_req\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_status_req\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_signal_req\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_action_req\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_repl_payload\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "static void \fBv0_free_req_payload\fP (void *UPK_DATA_PTR)"
.br
.ti -1c
.RI "void \fBv0_free_payload\fP (\fBupk_packet_t\fP *pkt)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_req_seq_start\fP (\fBupk_req_msgtype_t\fP msg_seq_type, uint32_t msg_seq_count)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_req_seq_end\fP (bool commit)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_action_req\fP (char *svc_id, char *action)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_signal_req\fP (char *svc_id, \fBupk_signal_t\fP signal, bool signal_sid, bool signal_pgrp)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_list_req\fP (void)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_status_req\fP (char *svc_id)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_subscr_req\fP (char *svc_id, bool all_svcs)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_unsubs_req\fP (char *svc_id, bool all_svcs)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_discon_req\fP (void)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_repl_seq_start\fP (\fBupk_repl_msgtype_t\fP msg_seq_type, uint32_t msg_seq_count)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_repl_seq_end\fP (bool commit)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_result_repl\fP (char *msg, bool successful)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_listing_repl\fP (char *svc_id)"
.br
.ti -1c
.RI "static uint32_t \fBget_svcinfo_len\fP (\fBv0_svcinfo_t\fP s)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_svcinfo_repl\fP (char *svc_id, \fBv0_svcinfo_t\fP *svcinfo)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_ack_repl\fP (void)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_error_repl\fP (char *svc_id, char *msg, \fBupk_errlevel_t\fP errlevel)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_pub_pubmsg\fP (void)"
.br
.ti -1c
.RI "\fBupk_packet_t\fP * \fBv0_create_cancel_pubmsg\fP (void)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBfree_data_t\fP \fBfree_pkt_dispatch\fP []"
.br
.ti -1c
.RI "static \fBfree_data_t\fP \fBfree_req_dispatch\fP []"
.br
.ti -1c
.RI "static \fBfree_data_t\fP \fBfree_repl_dispatch\fP []"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define PROTOCOL_VERSION   0"
.PP
.SS "#define UPK_END_HELPER(PKT_TYPE)   return upk_create_pkt(UPK_DATA, UPK_DATA_LEN, PKT_TYPE, PROTOCOL_VERSION)"
.PP
.SS "#define UPK_HELPER_ANSISTRING(DEST, SRC)"
.PP
\fBValue:\fP
.PP
.nf
UPK_STRING_LENGTH = strnlen(SRC, UPK_MAX_STRING_LEN); \
    UPK_HELPER_BUF(DEST, SRC, UPK_STRING_LENGTH + 1); \
    UPK_DATA_LEN--
.fi
.SS "#define UPK_HELPER_BOOL(MEMB)   UPK_HELPER_UINT8(MEMB)"
.PP
.SS "#define UPK_HELPER_BUF(DEST, SRC, LEN)"
.PP
\fBValue:\fP
.PP
.nf
DEST = calloc(1, LEN); \
    memcpy(DEST,SRC,LEN); \
    UPK_DATA_LEN += LEN
.fi
.SS "#define UPK_HELPER_ENUM(MEMB)   UPK_HELPER_UINT32(MEMB)"
.PP
.SS "#define UPK_HELPER_STRING(MEMB)"
.PP
\fBValue:\fP
.PP
.nf
UPK_HELPER_ANSISTRING(UPK_DATA->MEMB, MEMB); \
    UPK_HELPER_UINT32_EXPLICIT(UPK_DATA->UPK_MEMB_TO_LEN(MEMB), UPK_STRING_LENGTH)
.fi
.SS "#define UPK_HELPER_UINT16(MEMB)   UPK_HELPER_UINT16_EXPLICIT(UPK_DATA->MEMB, MEMB);"
.PP
.SS "#define UPK_HELPER_UINT16_EXPLICIT(DEST, SRC)"
.PP
\fBValue:\fP
.PP
.nf
DEST = SRC; \
    UPK_DATA_LEN += sizeof(uint16_t)
.fi
.SS "#define UPK_HELPER_UINT32(MEMB)   UPK_HELPER_UINT32_EXPLICIT(UPK_DATA->MEMB, MEMB);"
.PP
.SS "#define UPK_HELPER_UINT32_EXPLICIT(DEST, SRC)"
.PP
\fBValue:\fP
.PP
.nf
DEST = SRC; \
    UPK_DATA_LEN += sizeof(uint32_t)
.fi
.SS "#define UPK_HELPER_UINT8(MEMB)   UPK_HELPER_UINT8_EXPLICIT(UPK_DATA->MEMB, MEMB);"
.PP
.SS "#define UPK_HELPER_UINT8_EXPLICIT(DEST, SRC)"
.PP
\fBValue:\fP
.PP
.nf
DEST = SRC; \
    UPK_DATA_LEN += sizeof(uint8_t)
.fi
.SS "#define UPK_INIT_HELPER(TYPE, MSGTYPE)"
.PP
\fBValue:\fP
.PP
.nf
TYPE *UPK_DATA = NULL; \
    uint32_t UPK_DATA_LEN = 0; \
    size_t UPK_STRING_LENGTH = 0; \
    UPK_DATA = calloc(1, sizeof(*UPK_DATA)); \
    UPK_DATA->msgtype = MSGTYPE; \
    UPK_DATA_LEN += 4; \
    UPK_DATA_LEN = UPK_DATA_LEN + 0; \
    UPK_STRING_LENGTH = UPK_STRING_LENGTH + 0
.fi
.SH "Typedef Documentation"
.PP 
.SS "typedef void(*) \fBfree_data_t\fP(void *)"
.PP
.SH "Function Documentation"
.PP 
.SS "static uint32_t get_svcinfo_len (\fBv0_svcinfo_t\fP s)\fC [static]\fP"
.PP
.SS "\fBupk_packet_t\fP* v0_create_ack_repl (void)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_action_req (char * svc_id, char * action)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_cancel_pubmsg (void)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_discon_req (void)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_error_repl (char * svc_id, char * msg, \fBupk_errlevel_t\fP errlevel)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_list_req (void)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_listing_repl (char * svc_id)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_pub_pubmsg (void)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_repl_seq_end (bool commit)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_repl_seq_start (\fBupk_repl_msgtype_t\fP msg_seq_type, uint32_t msg_seq_count)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_req_seq_end (bool commit)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_req_seq_start (\fBupk_req_msgtype_t\fP msg_seq_type, uint32_t msg_seq_count)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_result_repl (char * msg, bool successful)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_signal_req (char * svc_id, \fBupk_signal_t\fP signal, bool signal_sid, bool signal_pgrp)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_status_req (char * svc_id)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_subscr_req (char * svc_id, bool all_svcs)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_svcinfo_repl (char * svc_id, \fBv0_svcinfo_t\fP * svcinfo)"
.PP
.SS "\fBupk_packet_t\fP* v0_create_unsubs_req (char * svc_id, bool all_svcs)"
.PP
.SS "static void v0_free_action_req (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_error_repl (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_listing_repl (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "void v0_free_payload (\fBupk_packet_t\fP * pkt)"
.PP
.SS "static void v0_free_repl_payload (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_req_payload (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_result_repl (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_signal_req (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_status_req (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_subscr_req (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_svcinfo_repl (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SS "static void v0_free_unsubs_req (void * UPK_DATA_PTR)\fC [static]\fP"
.PP
.SH "Variable Documentation"
.PP 
.SS "\fBfree_data_t\fP \fBfree_pkt_dispatch\fP[]\fC [static]\fP"
.PP
\fBInitial value:\fP
.PP
.nf
 {
    [PKT_REQUEST] = v0_free_req_payload,
    [PKT_REPLY] = v0_free_repl_payload,
    [PKT_PUBMSG] = NULL,
}
.fi
.SS "\fBfree_data_t\fP \fBfree_repl_dispatch\fP[]\fC [static]\fP"
.PP
\fBInitial value:\fP
.PP
.nf
 {
    [REPL_SEQ_START] = NULL,
    [REPL_SEQ_END] = NULL,
    [REPL_RESULT] = v0_free_result_repl,
    [REPL_LISTING] = v0_free_listing_repl,
    [REPL_SVCINFO] = v0_free_svcinfo_repl,
    [REPL_ACK] = NULL,
    [REPL_ERROR] = v0_free_error_repl,
}
.fi
.SS "\fBfree_data_t\fP \fBfree_req_dispatch\fP[]\fC [static]\fP"
.PP
\fBInitial value:\fP
.PP
.nf
 {
    [REQ_SEQ_START] = NULL,
    [REQ_SEQ_END] = NULL,
    [REQ_ACTION] = v0_free_action_req,
    [REQ_SIGNAL] = v0_free_signal_req,
    [REQ_LIST] = NULL,
    [REQ_STATUS] = v0_free_status_req,
    [REQ_SUBSCRIBE] = v0_free_subscr_req,
    [REQ_UNSUBSCRIBE] = v0_free_unsubs_req,
    [REQ_DISCONNECT] = NULL,
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for libupkeeper from the source code.
