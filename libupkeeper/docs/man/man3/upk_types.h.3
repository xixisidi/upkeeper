.TH "upkeeper/upk_types.h" 3 "30 Jun 2011" "Version 1" "libupkeeper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
upkeeper/upk_types.h \- types common throughout libupkeeper. 
.SH SYNOPSIS
.br
.PP
\fC#include 'upk_std_include.h'\fP
.br
\fC#include 'upk_v0_protocol_structs.h'\fP
.br
\fC#include 'upk_uuid.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_upk_svclist\fP"
.br
.RI "\fIlinked list of service identifiers. \fP"
.ti -1c
.RI "struct \fB_upk_cust_actscr_list\fP"
.br
.RI "\fIlinked list of custom action scripts. \fP"
.ti -1c
.RI "struct \fB_upk_svcinfo\fP"
.br
.RI "\fIsee definition in *protocol_fields.h. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBUPK_MAX_STRING_LEN\fP   2048"
.br
.RI "\fIlongest allowable string (other than paths). \fP"
.ti -1c
.RI "#define \fBUPK_MAX_PATH_LEN\fP   8192"
.br
.RI "\fIlongest allowable path. \fP"
.ti -1c
.RI "#define \fBUPKLIST_METANODE\fP(TYPE, NAME)   struct { TYPE * head; TYPE * tail; TYPE * prevp; TYPE * nextp; TYPE * tempp; TYPE * thisp; uint32_t count; } * NAME"
.br
.RI "\fIdefinition of metanode for a given type. \fP"
.ti -1c
.RI "#define \fBUPKLIST_INIT\fP(TYPE, NAME)"
.br
.ti -1c
.RI "#define \fB_UPKLIST_NEWNODE\fP(NAME)   NAME->tempp = calloc(1,sizeof(*(NAME->tempp)))"
.br
.ti -1c
.RI "#define \fBUPKLIST_APPEND_THIS\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_APPEND\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_PREPEND_THIS\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_PREPEND\fP(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKLIST_NEXTNODE\fP(NAME)   ( (NAME->thisp) ? NAME->thisp->next : NULL )"
.br
.ti -1c
.RI "#define \fB_UPKLIST_FOREACH_CONTINUE\fP(NAME)   NAME->tempp = NULL, NAME->prevp = NAME->thisp, NAME->thisp = NAME->nextp, NAME->nextp = _UPKLIST_NEXTNODE(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKLIST_FOREACH_INIT\fP(NAME)   NAME->tempp = NULL, NAME->prevp = NULL, NAME->thisp = NAME->head, NAME->nextp = _UPKLIST_NEXTNODE(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_FOREACH\fP(NAME)   for( _UPKLIST_FOREACH_INIT(NAME); NAME->thisp != NULL; _UPKLIST_FOREACH_CONTINUE(NAME) )"
.br
.ti -1c
.RI "#define \fBUPKLIST_SWAP\fP(NAME, A, APREV, B, BPREV)"
.br
.ti -1c
.RI "#define \fBUPKLIST_UNLINK\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_FREE\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_METANODE\fP(TYPE, NAME)   struct { TYPE * head; TYPE * tail; TYPE * prevp; TYPE * nextp; TYPE * tempp; TYPE * thisp; uint32_t count; } * NAME"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_NEWNODE\fP(NAME)   NAME->tempp = calloc(1,sizeof(*(NAME->tempp)))"
.br
.ti -1c
.RI "#define \fBUPKDLIST_INIT\fP(TYPE, NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_APPEND_THIS\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_APPEND\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_PREPEND_THIS\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_PREPEND\fP(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_NEXTNODE\fP(NAME)   ( (NAME->thisp) ? NAME->thisp->next : NULL )"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_PREVNODE\fP(NAME)   ( (NAME->thisp) ? NAME->thisp->prev : NULL )"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_FOREACH_CONTINUE\fP(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_FOREACH_INIT\fP(NAME)   NAME->tempp = NULL, NAME->prevp = NULL, NAME->thisp = NAME->head, NAME->nextp = _UPKDLIST_NEXTNODE(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_FOREACH\fP(NAME)   for( _UPKDLIST_FOREACH_INIT(NAME); NAME->thisp != NULL; _UPKDLIST_FOREACH_CONTINUE(NAME) )"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_FOREACH_R_CONTINUE\fP(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_FOREACH_R_INIT\fP(NAME)   NAME->tempp = NULL, NAME->nextp = NULL, NAME->thisp = NAME->tail, NAME->prevp = _UPKDLIST_PREVNODE(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_FOREACH_REVERSE\fP(NAME)   for( _UPKDLIST_FOREACH_R_INIT(NAME); NAME->thisp != NULL; _UPKDLIST_FOREACH_R_CONTINUE(NAME) )"
.br
.ti -1c
.RI "#define \fBUPKDLIST_SWAP\fP(NAME, A, B)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_UNLINK\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_FREE\fP(NAME)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fB_upk_svclist\fP \fBupk_svclist_t\fP"
.br
.RI "\fIlinked list of service identifiers. \fP"
.ti -1c
.RI "typedef \fB_upk_cust_actscr_list\fP \fBupk_cust_actscr_list_t\fP"
.br
.RI "\fIlinked list of custom action scripts. \fP"
.ti -1c
.RI "typedef \fB_upk_svcinfo\fP \fBupk_svcinfo_t\fP"
.br
.RI "\fIsee definition in *protocol_fields.h. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBupk_state_t\fP { \fBUPK_STATE_UNDEFINED\fP, \fBUPK_STATE_RUNNING\fP, \fBUPK_STATE_STOPPED\fP, \fBUPK_STATE_SHUTDOWN\fP }"
.br
.RI "\fIrun states to report to clients. \fP"
.ti -1c
.RI "enum \fBupk_signal_t\fP { \fBUPK_SIG_HUP\fP =  1, \fBUPK_SIG_INT\fP =  2, \fBUPK_SIG_QUIT\fP =  3, \fBUPK_SIG_ILL\fP =  4, \fBUPK_SIG_TRAP\fP =  5, \fBUPK_SIG_ABRT\fP =  6, \fBUPK_SIG_BUS\fP =  7, \fBUPK_SIG_FPE\fP =  8, \fBUPK_SIG_KILL\fP =  9, \fBUPK_SIG_USR1\fP =  10, \fBUPK_SIG_SEGV\fP =  11, \fBUPK_SIG_USR2\fP =  12, \fBUPK_SIG_PIPE\fP =  13, \fBUPK_SIG_ALRM\fP =  14, \fBUPK_SIG_TERM\fP =  15, \fBUPK_SIG_STKFLT\fP =  16, \fBUPK_SIG_CHLD\fP =  17, \fBUPK_SIG_CONT\fP =  18, \fBUPK_SIG_STOP\fP =  19, \fBUPK_SIG_TSTP\fP =  20, \fBUPK_SIG_TTIN\fP =  21, \fBUPK_SIG_TTOU\fP =  22, \fBUPK_SIG_URG\fP =  23, \fBUPK_SIG_XCPU\fP =  24, \fBUPK_SIG_XFSZ\fP =  25, \fBUPK_SIG_VTALRM\fP =  26, \fBUPK_SIG_PROF\fP =  27, \fBUPK_SIG_WINCH\fP =  28, \fBUPK_SIG_IO\fP =  29, \fBUPK_SIG_PWR\fP =  30, \fBUPK_SIG_SYS\fP =  31 }"
.br
.RI "\fIsignal names. \fP"
.in -1c
.SH "Detailed Description"
.PP 
types common throughout libupkeeper. 

Types used commonly, and (ideally) not more suitably defined elsewhere. 
.SH "Define Documentation"
.PP 
.SS "#define _UPKDLIST_FOREACH_CONTINUE(NAME)"
.PP
\fBValue:\fP
.PP
.nf
NAME->tempp = NULL, NAME->prevp = NAME->thisp, NAME->thisp = NAME->nextp, \
    NAME->nextp = _UPKDLIST_NEXTNODE(NAME), NAME->prevp = _UPKDLIST_PREVNODE(NAME)
.fi
.SS "#define _UPKDLIST_FOREACH_INIT(NAME)   NAME->tempp = NULL, NAME->prevp = NULL, NAME->thisp = NAME->head, NAME->nextp = _UPKDLIST_NEXTNODE(NAME)"
.PP
.SS "#define _UPKDLIST_FOREACH_R_CONTINUE(NAME)"
.PP
\fBValue:\fP
.PP
.nf
NAME->tempp = NULL, NAME->nextp = NAME->thisp, NAME->thisp = NAME->prevp, \
    NAME->prevp = _UPKDLIST_PREVNODE(NAME), NAME->nextp = _UPKDLIST_NEXTNODE(NAME)
.fi
.SS "#define _UPKDLIST_FOREACH_R_INIT(NAME)   NAME->tempp = NULL, NAME->nextp = NULL, NAME->thisp = NAME->tail, NAME->prevp = _UPKDLIST_PREVNODE(NAME)"
.PP
.SS "#define _UPKDLIST_NEWNODE(NAME)   NAME->tempp = calloc(1,sizeof(*(NAME->tempp)))"
.PP
.SS "#define _UPKDLIST_NEXTNODE(NAME)   ( (NAME->thisp) ? NAME->thisp->next : NULL )"
.PP
.SS "#define _UPKDLIST_PREVNODE(NAME)   ( (NAME->thisp) ? NAME->thisp->prev : NULL )"
.PP
.SS "#define _UPKLIST_FOREACH_CONTINUE(NAME)   NAME->tempp = NULL, NAME->prevp = NAME->thisp, NAME->thisp = NAME->nextp, NAME->nextp = _UPKLIST_NEXTNODE(NAME)"
.PP
.SS "#define _UPKLIST_FOREACH_INIT(NAME)   NAME->tempp = NULL, NAME->prevp = NULL, NAME->thisp = NAME->head, NAME->nextp = _UPKLIST_NEXTNODE(NAME)"
.PP
.SS "#define _UPKLIST_NEWNODE(NAME)   NAME->tempp = calloc(1,sizeof(*(NAME->tempp)))"
.PP
.SS "#define _UPKLIST_NEXTNODE(NAME)   ( (NAME->thisp) ? NAME->thisp->next : NULL )"
.PP
.SS "#define UPK_MAX_PATH_LEN   8192"
.PP
longest allowable path. 
.PP
.SS "#define UPK_MAX_STRING_LEN   2048"
.PP
longest allowable string (other than paths). 
.PP
.SS "#define UPKDLIST_APPEND(NAME)"
.PP
\fBValue:\fP
.PP
.nf
NAME->thisp = NAME->tail; \
    NAME->prevp = (NAME->thisp) ? NAME->thisp->prev : NAME->head; \
    UPKDLIST_APPEND_THIS(NAME)
.fi
.SS "#define UPKDLIST_APPEND_THIS(NAME)"
.PP
\fBValue:\fP
.PP
.nf
_UPKDLIST_NEWNODE(NAME); \
    NAME->tempp->next = NAME->nextp; \
    if(NAME->thisp) { NAME->thisp->next = NAME->tempp; NAME->tempp->prev = NAME->thisp; } \
    if(! NAME->nextp ) { NAME->tail = NAME->tempp; } \
    if(! NAME->prevp && NAME->count == 0 ) { NAME->head = NAME->tempp; } \
    ++NAME->count; \
    NAME->thisp = NAME->tempp;
.fi
.SS "#define UPKDLIST_FOREACH(NAME)   for( _UPKDLIST_FOREACH_INIT(NAME); NAME->thisp != NULL; _UPKDLIST_FOREACH_CONTINUE(NAME) )"
.PP
.SS "#define UPKDLIST_FOREACH_REVERSE(NAME)   for( _UPKDLIST_FOREACH_R_INIT(NAME); NAME->thisp != NULL; _UPKDLIST_FOREACH_R_CONTINUE(NAME) )"
.PP
.SS "#define UPKDLIST_FREE(NAME)"
.PP
\fBValue:\fP
.PP
.nf
UPKDLIST_FOREACH(NAME) { \
        UPKDLIST_UNLINK(NAME); \
    }\
    if(NAME) { free(NAME); }
.fi
.SS "#define UPKDLIST_INIT(TYPE, NAME)"
.PP
\fBValue:\fP
.PP
.nf
UPKDLIST_METANODE(TYPE, NAME) = NULL; \
    NAME = calloc(1, sizeof(*NAME)); \
.fi
.SS "#define UPKDLIST_METANODE(TYPE, NAME)   struct { TYPE * head; TYPE * tail; TYPE * prevp; TYPE * nextp; TYPE * tempp; TYPE * thisp; uint32_t count; } * NAME"
.PP
.SS "#define UPKDLIST_PREPEND(NAME)"
.PP
\fBValue:\fP
.PP
.nf
NAME->prevp = NULL; \
    NAME->thisp = NAME->head; \
    UPKDLIST_PREPEND_THIS(NAME)
.fi
.SS "#define UPKDLIST_PREPEND_THIS(NAME)"
.PP
\fBValue:\fP
.PP
.nf
_UPKDLIST_NEWNODE(NAME); \
    NAME->tempp->next = NAME->thisp; \
    if(NAME->thisp) {  NAME->tempp->prev = NAME->thisp->prev; NAME->thisp->prev = NAME->tempp; } \
    if(! NAME->nextp ) { NAME->tail = NAME->tempp; } \
    if(! NAME->prevp ) { NAME->head = NAME->tempp; } else { NAME->prevp->next = NAME->tempp; } \
    ++NAME->count; \
    NAME->thisp = NAME->tempp
.fi
.SS "#define UPKDLIST_SWAP(NAME, A, B)"
.PP
\fBValue:\fP
.PP
.nf
NAME->tempp = calloc(1,sizeof(*NAME->tempp)); \
    A->prev->next = B; \
    B->prev->next = A; \
    NAME->tempp->next = A->next; \
    NAME->tempp->prev = A->prev; \
    A->next = B->next; \
    A->prev = B->prev; \
    B->next = NAME->tempp->next; \
    B->prev = NAME->tempp->prev; \
    free(NAME->tempp); NAME->tempp = NULL
.fi
.SS "#define UPKDLIST_UNLINK(NAME)"
.PP
\fBValue:\fP
.PP
.nf
if(NAME->thisp) { \
        if(! NAME->prevp ) { NAME->head = NAME->nextp; } else { NAME->prevp->next = NAME->nextp; } \
        if(! NAME->nextp ) { NAME->tail = NAME->prevp; } else { NAME->nextp->prev = NAME->prevp; }  \
        free(NAME->thisp); NAME->thisp = NULL; \
        --NAME->count; \
    }
.fi
.SS "#define UPKLIST_APPEND(NAME)"
.PP
\fBValue:\fP
.PP
.nf
NAME->thisp = NAME->tail; \
    NAME->prevp = (NAME->prevp) ? NAME->prevp : NAME->head; \
    UPKLIST_APPEND_THIS(NAME); \
    NAME->prevp = NULL
.fi
.SS "#define UPKLIST_APPEND_THIS(NAME)"
.PP
\fBValue:\fP
.PP
.nf
_UPKLIST_NEWNODE(NAME); \
    NAME->tempp->next = NAME->nextp; \
    if(! NAME->nextp ) { NAME->tail = NAME->tempp; } \
    if(! NAME->prevp && NAME->count == 0 ) { NAME->head = NAME->tempp; } \
    if(NAME->thisp) { NAME->thisp->next = NAME->tempp; } \
    ++NAME->count; \
    NAME->thisp = NAME->tempp;
.fi
.SS "#define UPKLIST_FOREACH(NAME)   for( _UPKLIST_FOREACH_INIT(NAME); NAME->thisp != NULL; _UPKLIST_FOREACH_CONTINUE(NAME) )"
.PP
.SS "#define UPKLIST_FREE(NAME)"
.PP
\fBValue:\fP
.PP
.nf
UPKLIST_FOREACH(NAME) { \
        UPKLIST_UNLINK(NAME); \
    }\
    if(NAME) { free(NAME); }
.fi
.SS "#define UPKLIST_INIT(TYPE, NAME)"
.PP
\fBValue:\fP
.PP
.nf
UPKLIST_METANODE(TYPE, NAME) = NULL; \
    NAME = calloc(1, sizeof(*NAME))
.fi
.SS "#define UPKLIST_METANODE(TYPE, NAME)   struct { TYPE * head; TYPE * tail; TYPE * prevp; TYPE * nextp; TYPE * tempp; TYPE * thisp; uint32_t count; } * NAME"
.PP
definition of metanode for a given type. 
.PP
this macro contains a pionter; so if you want to use it to create a typedef, it would look something like:
.PP
\fBUPKLIST_METANODE(my_listtype_t, listtype_metanode_p)\fP, listtype_metanode_t;
.PP
or similar. 
.SS "#define UPKLIST_PREPEND(NAME)"
.PP
\fBValue:\fP
.PP
.nf
NAME->prevp = NULL; \
    NAME->thisp = NAME->head; \
    UPKLIST_PREPEND_THIS(NAME)
.fi
.SS "#define UPKLIST_PREPEND_THIS(NAME)"
.PP
\fBValue:\fP
.PP
.nf
_UPKLIST_NEWNODE(NAME); \
    NAME->tempp->next = NAME->thisp; \
    if(! NAME->nextp ) { NAME->tail = NAME->tempp; } \
    if(! NAME->prevp ) { NAME->head = NAME->tempp; } else { NAME->prevp->next = NAME->tempp; } \
    ++NAME->count; \
    NAME->thisp = NAME->tempp
.fi
.SS "#define UPKLIST_SWAP(NAME, A, APREV, B, BPREV)"
.PP
\fBValue:\fP
.PP
.nf
NAME->tempp = calloc(1,sizeof(*NAME->tempp)); \
    APREV->next = B; \
    BPREV->next = A; \
    NAME->tempp->next = A->next; \
    A->next = B->next; \
    B->next = NAME->tempp->next; \
    free(NAME->tempp); NAME->tempp = NULL
.fi
.SS "#define UPKLIST_UNLINK(NAME)"
.PP
\fBValue:\fP
.PP
.nf
if(NAME->thisp) { \
        if(! NAME->prevp ) { NAME->head = NAME->nextp; } else { NAME->prevp->next = NAME->nextp; } \
        if(! NAME->nextp ) { NAME->tail = NAME->prevp; } \
        free(NAME->thisp); NAME->thisp = NULL; \
        --NAME->count; \
    }
.fi
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_upk_cust_actscr_list\fP \fBupk_cust_actscr_list_t\fP"
.PP
linked list of custom action scripts. 
.PP
.SS "typedef struct \fB_upk_svcinfo\fP  \fBupk_svcinfo_t\fP"
.PP
see definition in *protocol_fields.h. 
.PP
.SS "typedef struct \fB_upk_svclist\fP \fBupk_svclist_t\fP"
.PP
linked list of service identifiers. 
.PP
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBupk_signal_t\fP"
.PP
signal names. 
.PP
List of signal names, so that the platform's signal numbering is no longer significant for data storage, or communication with controller 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIUPK_SIG_HUP \fP\fP
hup 
.TP
\fB\fIUPK_SIG_INT \fP\fP
int 
.TP
\fB\fIUPK_SIG_QUIT \fP\fP
quit 
.TP
\fB\fIUPK_SIG_ILL \fP\fP
ill 
.TP
\fB\fIUPK_SIG_TRAP \fP\fP
trap 
.TP
\fB\fIUPK_SIG_ABRT \fP\fP
abrt 
.TP
\fB\fIUPK_SIG_BUS \fP\fP
bus 
.TP
\fB\fIUPK_SIG_FPE \fP\fP
fpe 
.TP
\fB\fIUPK_SIG_KILL \fP\fP
kill 
.TP
\fB\fIUPK_SIG_USR1 \fP\fP
usr1 
.TP
\fB\fIUPK_SIG_SEGV \fP\fP
segv 
.TP
\fB\fIUPK_SIG_USR2 \fP\fP
usr2 
.TP
\fB\fIUPK_SIG_PIPE \fP\fP
pipe 
.TP
\fB\fIUPK_SIG_ALRM \fP\fP
alrm 
.TP
\fB\fIUPK_SIG_TERM \fP\fP
term 
.TP
\fB\fIUPK_SIG_STKFLT \fP\fP
stkflt 
.TP
\fB\fIUPK_SIG_CHLD \fP\fP
chld 
.TP
\fB\fIUPK_SIG_CONT \fP\fP
cont 
.TP
\fB\fIUPK_SIG_STOP \fP\fP
stop 
.TP
\fB\fIUPK_SIG_TSTP \fP\fP
tstp 
.TP
\fB\fIUPK_SIG_TTIN \fP\fP
ttin 
.TP
\fB\fIUPK_SIG_TTOU \fP\fP
ttou 
.TP
\fB\fIUPK_SIG_URG \fP\fP
urg 
.TP
\fB\fIUPK_SIG_XCPU \fP\fP
xcpu 
.TP
\fB\fIUPK_SIG_XFSZ \fP\fP
xfsz 
.TP
\fB\fIUPK_SIG_VTALRM \fP\fP
vtalrm 
.TP
\fB\fIUPK_SIG_PROF \fP\fP
prof 
.TP
\fB\fIUPK_SIG_WINCH \fP\fP
winch 
.TP
\fB\fIUPK_SIG_IO \fP\fP
io 
.TP
\fB\fIUPK_SIG_PWR \fP\fP
pwr 
.TP
\fB\fIUPK_SIG_SYS \fP\fP
sys 
.SS "enum \fBupk_state_t\fP"
.PP
run states to report to clients. 
.PP
The current state of a monitored service 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIUPK_STATE_UNDEFINED \fP\fP
unknown/undefined; probably an error 
.TP
\fB\fIUPK_STATE_RUNNING \fP\fP
the service is running 
.TP
\fB\fIUPK_STATE_STOPPED \fP\fP
the service is stopped 
.TP
\fB\fIUPK_STATE_SHUTDOWN \fP\fP
the service is stopped, and its buddy is not running 
.SH "Author"
.PP 
Generated automatically by Doxygen for libupkeeper from the source code.
