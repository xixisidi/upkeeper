=head2 Upkeeper Architecture

Upkeeper launches Unix daemon processes, keeps them up,
and displays their real-time status in a terminal-based interface.

Every process controlled by upkeeper 
gets a 'buddy' process assigned which watches over it 
and restarts it if necessary. Upkeeper also features a single buddy 
controller daemon which bootstraps the system and monitors its state.

All state is stored in a SQLite database, which also serves as 
communication mechanism between the buddy controller and the 
real-time UI.

Upkeeper also maintains a collection of historical process data and 
displays useful stats on which processes where restarted, how often and when.

=head3 Buddy Controller

At system boot time, the Buddy Controller rummages through the 'services'
table of the SQLite database to figure out which processes are defined
and what their desired and actual state is. Both desired and actual 
state of each process are stored in the table.

    CREATE TABLE services (
        id            INTEGER PRIMARY KEY,
        package       VARCHAR,
        service       VARCHAR,
        procrun_id    INT,
        state_desired VARCHAR,
        state_actual  VARCHAR,
        FOREIGN KEY (procrun_id)
            REFERENCES procrun(id)
    );

At startup, if the buddy controller notices a process that is down
but should be up, it will bring it up by launching a buddy whose job
it then is to start the process and restart it should it ever 
fall down. 

Every service references an entry in the C<procrun> table, which specifies
the command line of the application process, its pid (once it has been
launched) and its buddy's pid (bpid):

    CREATE TABLE procruns (
        id            INTEGER PRIMARY KEY,
        cmdline       VARCHAR,
        user          VARCHAR,
        pid           INTEGER,
        bpid          INTEGER
    );

=head3 Buddy

As soon as 
the buddy has launched the process, it marks it 'started' in the 
database table and enters its pid. 
If the application process ends or crashes, the buddy detects this 
immediately, since he receives a sigchild signal in this case.
It then records that fact in the historical events table, and then tries 
to bring 
the application back up immediately. Configuration values defined how often 
the buddy tries to restart the process, how long to pause between
restarts and when to give up.

When the buddy sets the process status to 'started', a SQLite trigger
notifies a list of subscribers, stored in the listeners table:

    CREATE TABLE listeners (
        id        INTEGER PRIMARY KEY,
        component VARCHAR,
        signal    INTEGER,
        pid       INTEGER
    );

So far, the only subscriber to this table is the terminal UI C<uptop>
which wakes up when receiving the Unix signal and refreshes its display.
This mechanism allows for a real-time display even with multiple instances
of C<uptop> running on the same box.

To shut down a buddy with its controlled application process, the 
administrator simply calls a command which sets the application's status
to C<stop> in the database. 
An SQLite trigger on the C<services> table notices this and
sends a TERM signal to the buddy, which first brings down the application
and then shuts down itself.

=head3 Database Corruption

If the SQLite database disk image gets corrupted for whatever reason, 
started application processes will keep running along with their buddies. 

Database interactions only take place if the admin tries to modify 
settings or a buddy trying to restart a crashed application process.
In this case the problem will become evident and reported to the 
system administrator, who can then recreate the static settings in
the database with a yinst command (application command lines and
desired status) and kill existing application processes. After restarting
the buddy controller with the --bootstrap option 
everything should be back to normal.

=head3 Buddy Controller Restart

If the buddy controller crashes for whatever reason, it can simply restart,
go through the database tables and verify that all services that have
a desired state of 'started' also have an actual state of 'started'.
Secondly, it verifies that every service marked as 'started' actually has
a running Buddy process. If a buddy process is missing (in the rare event
of a buddy crash), it restarts it.

If the entire host crashes, all processes are down and when the buddy
controller gets started with the --bootstrap option via the startup script or 
inittab setting, it re-initializes the database automatically.

=head3 Buddy Crash

If the buddy crashes, the buddy controller will notice on the next
patrol round that the process with the stored bpid is no longer running.
It will restart the buddy along with the application.
