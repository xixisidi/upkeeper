=head2 Buddy Controller

When the Buddy Controller starts up (usually at sytem reboot), it sifts 
through the upkeeper data store and figures out which application
processes need to be started. If an application is down, but its
desired state is up, the buddy controller restarts it with a buddy
process.

upkeeper-buddy-controller keeps running as a daemon at all times and 
gets notified by the buddies
if any of their controlled applications was shut down or crashed. In this
case, the buddy receives a SIGCHLD signal (or the blocking waitpid() 
triggers) and marks the application with status 'stop' in the data store.
It also sends a message to the buddy controller's control port (or SIGHUP?), 
which triggers a new scan of processes to be restarted.

upkeeper-buddy-controller needs to be started before any other application in
the system. If started with the --bootstrap option, upkeeper-buddy-controller
assumes that all of its applications are down, if they're marked running in the
data store. This is necessary, as the system might crash and reboot with all
applications down.


before

* after system reboot, how mark processes as 'stopped'?

=head2 Upkeeper Buddy

Upkeeper Buddy takes care of launching supervised processes and reporting 
their status to the upkeeper database.

When called via

    upkeeper-buddy cmd-line

upkeeper-buddy launches the application process in cmd-line with a 'buddy'
which updates the upkeeper database when the application has been started
and when it got stopped or crashed.

=head2 Upkeeper Buddy API

=over 4

=item * upk_buddy_start

    int buddy_pid = upk_buddy_start(
      sqlite3  pdb, 
      char    *package,
      char    *service,
      const   *char argv[], 
      const   *char env[]
    );

Forks two processes, a buddy process (ps line changed to "upk-buddy-argv[0]")
and the application process given in argv[] with the environment in
env[].

The buddy process sets up a SIGCHLD signal handler and forks the application
process which then execle()s the command line given in argv[]. 
The buddy then updates the process 
status to "start" in the upkeeper database. It stays alive and blocks via 
waitpid until the forked application process dies, which it gets notified
of immediately via the SIGCHLD/waitpid setup. As soon as this happens, 
it updates the status of the process in the upkeeper database to "stop".

Returns the buddy process pid on success and a number < 0 on error.

=item * upk_buddy_start

    int
    upk_buddy_stop(
      sqlite3  pdb, 
      int      buddy_pid,
    );

Stops the process launched by a previous call to upk_buddy_start() and
updates the upkeeper database accordingly.

Returns 0 on success and a number < 0 on error.

=item * upk_buddy_call_home

    int
    upk_buddy_call_home(
      sqlite3  pdb, 
      int      buddy_pid,
    );

Launched application processes can opt to report their status back to the
buddy controller in regular intervals. This ensures that the buddy controller
can be sure that the application process actually is making progress
instead of just being alive in a vegetative state.
