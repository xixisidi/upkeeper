=head2 Buddy Controller

When the Upkeeper Buddy Controller starts up (usually at system reboot via
inittab/respawn), it sifts through the upkeeper data store and figures out 
which application processes need to be started. If an application's actual 
state is down, but its desired state is up, the buddy controller restarts 
it with a buddy process.

A buddy process launches an application process and takes
care of the necessary status bookkeeping chores with the upkeeper backend. 
After forking, the buddy's parent process issues a blocking waidpid()
on the child, which execs the application process.

The buddy also reacts to SIGTERM signals, which it interprets as a 'stop'
command for the application process. Upon receiving a SIGTERM, the buddy
sends a SIGTERM signal to the forked application process and then waits 
a configurable time until it stops. After a configurable number of 
retries, it forces the application process to stop via SIGKILL. Once it has
accomplished stopping the application (and verified that it's down), 
it marks its new actual state in the upkeeper data store and exits.

The Upkeeper Buddy Controller needs to be started before any other application
in the system. If started with the --bootstrap option,
upkeeper-buddy-controller assumes that all of its applications are down, even
if they're marked running in the data store. This is necessary at system
reboot, as the system might have crashed and rebooted with all applications
down, without the opportunity to mark them as such in the data store.

The Upkeeper Buddy Controller keeps running as a daemon at all times and gets
notified by the buddies if any of their controlled applications was shut down
or crashed. In this case, the buddy's blocking waitpid() triggers and 
the buddy marks the application as 'stopped' in the data store.
This also sends a SIGHUP signal to the buddy controller via an SQLite 
update trigger on the services table, which causes the controller to 
initiate a new table scan, finding out which apps are to be restarted.

=head2 Upkeeper Buddy

Upkeeper Buddy takes care of launching supervised processes and reporting 
their status to the upkeeper database.

When called via

    upkeeper-buddy cmd-line

upkeeper-buddy launches the application process in cmd-line with a 'buddy'
which updates the upkeeper database when the application has been started
and when it got stopped or crashed.

=head2 Upkeeper Buddy API

=over 4

=item * upk_buddy_start

    int buddy_pid = upk_buddy_start(
      sqlite3  pdb, 
      char    *package,
      char    *service,
      const   *char argv[], 
      const   *char env[]
    );

Forks two processes, a buddy process (ps line changed to "upk-buddy-argv[0]")
and the application process given in argv[] with the environment in
env[].

The buddy process sets up a SIGCHLD signal handler and forks the application
process which then execle()s the command line given in argv[]. 
The buddy then updates the process 
status to "start" in the upkeeper database. It stays alive and blocks via 
waitpid until the forked application process dies, which it gets notified
of immediately via the SIGCHLD/waitpid setup. As soon as this happens, 
it updates the status of the process in the upkeeper database to "stop".

Returns the buddy process pid on success and a number < 0 on error.

=item * upk_buddy_stop

    int
    upk_buddy_stop(
      sqlite3  pdb, 
      int      buddy_pid,
    );

Stops the process launched by a previous call to upk_buddy_start() and
updates the upkeeper database accordingly.

Returns 0 on success and a number < 0 on error.

=item * upk_buddy_call_home

    int
    upk_buddy_call_home(
      sqlite3  pdb, 
      int      buddy_pid,
    );

Launched application processes can opt to report their status back to the
buddy controller in regular intervals. This ensures that the buddy controller
can be sure that the application process actually is making progress
instead of just being alive in a vegetative state.
