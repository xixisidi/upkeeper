.TH "libupkeeper/upkeeper/upk_v0_protocol_structs.h" 3 "Wed Sep 14 2011" "Version 1" "upkeeper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libupkeeper/upkeeper/upk_v0_protocol_structs.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBUPK_V0_UPK_REQ_SEQ_START_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_UPK_REQ_SEQ_END_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REQ_ACTION_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REQ_SIGNAL_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REQ_LIST_T_FIELDS\fP   \fBupk_msgtype_t\fP       msgtype"
.br
.ti -1c
.RI "#define \fBUPK_V0_REQ_STATUS_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REQ_SUBSCR_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REQ_UNSUBS_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REQ_DISCON_T_FIELDS\fP   \fBupk_msgtype_t\fP       msgtype"
.br
.ti -1c
.RI "#define \fBUPK_V0_UPK_REPL_SEQ_START_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_UPK_REPL_SEQ_END_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REPL_RESULT_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REPL_LISTING_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_SVCINFO_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REPL_SVCINFO_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_REPL_ACK_T_FIELDS\fP   \fBupk_msgtype_t\fP           msgtype"
.br
.ti -1c
.RI "#define \fBUPK_V0_REPL_ERROR_T_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBUPK_V0_PUBLICATION_T_FIELDS\fP   \fBupk_msgtype_t\fP       msgtype"
.br
.ti -1c
.RI "#define \fBUPK_V0_CANCELATION_T_FIELDS\fP   \fBupk_msgtype_t\fP       msgtype"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define UPK_V0_CANCELATION_T_FIELDS   \fBupk_msgtype_t\fP       msgtype"
.SS "#define UPK_V0_PUBLICATION_T_FIELDS   \fBupk_msgtype_t\fP       msgtype"
.SS "#define UPK_V0_REPL_ACK_T_FIELDS   \fBupk_msgtype_t\fP           msgtype"
.SS "#define UPK_V0_REPL_ERROR_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t           msgtype; \
    upk_errlevel_t          errlevel; \
    upk_errno_t             uerrno; \
    uint32_t                msg_len; \
    char                    msg[UPK_MAX_STRING_LEN]; \
    uint32_t                svc_id_len; \
    char                    svc_id[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_REPL_LISTING_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t      msgtype; \
    uint32_t                svc_id_len; \
    char                    svc_id[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_REPL_RESULT_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t      msgtype; \
    bool                    successful; \
    uint32_t                msg_len; \
    char                    msg[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_REPL_SVCINFO_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t           msgtype; \
    uint32_t                svcinfo_len;                   /* sizeof struct can be arch dependant; immaterial on unix */ \
                                                           /* domain socket; but to keep this network safe, I'm going */ \
                                                           /* to go ahead and serialize it the same as everything else */ \
    v0_svcinfo_t            svcinfo; \
    uint32_t                svc_id_len; \
    char                    svc_id[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_REQ_ACTION_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t       msgtype; \
    uint32_t                svc_id_len; \
    char                    svc_id[UPK_MAX_STRING_LEN]; \
    uint32_t                action_len; \
    char                    action[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_REQ_DISCON_T_FIELDS   \fBupk_msgtype_t\fP       msgtype"
.SS "#define UPK_V0_REQ_LIST_T_FIELDS   \fBupk_msgtype_t\fP       msgtype"
.SS "#define UPK_V0_REQ_SIGNAL_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t       msgtype; \
    upk_signal_t       signal; \
    bool                    signal_sid; \
    bool                    signal_pgrp; \
    uint32_t                svc_id_len; \
    char                    svc_id[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_REQ_STATUS_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t       msgtype; \
    uint32_t                svc_id_len; \
    char                    svc_id[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_REQ_SUBSCR_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t       msgtype; \
    bool                    all_svcs;                     /* send a req with all=true to subscribe to everything in */ \
                                                          /* one shot; svc_id will be ignored, and should have len 0 */ \
    uint32_t                svc_id_len; \
    char                    svc_id[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_REQ_UNSUBS_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t       msgtype; \
    bool                    all_svcs; \
    uint32_t                svc_id_len; \
    char                    svc_id[UPK_MAX_STRING_LEN]
.fi
.SS "#define UPK_V0_SVCINFO_T_FIELDS"\fBValue:\fP
.PP
.nf
uint32_t                last_action_time; \
    uint32_t                last_action_status; \
    uint32_t                last_action_name_len; \
    char                    last_action_name[UPK_MAX_STRING_LEN]; \
    uint32_t                last_signal_time; \
    uint32_t                last_signal_status; \
    upk_signal_t            last_signal_name; \
    uint32_t                buddy_pid; \
    uint32_t                proc_pid; \
    upk_state_t             current_state; \
    upk_state_t             prior_state
.fi
.SS "#define UPK_V0_UPK_REPL_SEQ_END_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t      msgtype; \
    bool                    commit
.fi
.SS "#define UPK_V0_UPK_REPL_SEQ_START_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t      msgtype; \
    upk_msgtype_t      msg_seq_type; \
    uint32_t                msg_seq_count
.fi
.SS "#define UPK_V0_UPK_REQ_SEQ_END_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t       msgtype; \
    bool                    commit                         /* if false, the preceding sequence of requests since the */ \
.fi
.SS "#define UPK_V0_UPK_REQ_SEQ_START_T_FIELDS"\fBValue:\fP
.PP
.nf
upk_msgtype_t       msgtype; \
    upk_msgtype_t       msg_seq_type; \
    uint32_t                msg_seq_count
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for upkeeper from the source code.
