.TH "libupkeeper/upkeeper/upk_types.h" 3 "Wed Dec 7 2011" "Version 1" "upkeeper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libupkeeper/upkeeper/upk_types.h \- 
.PP
types common throughout libupkeeper.  

.SH SYNOPSIS
.br
.PP
\fC#include 'upk_std_include.h'\fP
.br
\fC#include 'upk_v0_protocol_structs.h'\fP
.br
\fC#include 'upk_uuid.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_upk_svcid\fP"
.br
.RI "\fIlinked list of service identifiers. \fP"
.ti -1c
.RI "struct \fB_upk_cust_actscr_list\fP"
.br
.RI "\fIlinked list of custom action scripts. \fP"
.ti -1c
.RI "struct \fB_upk_stringlist\fP"
.br
.ti -1c
.RI "struct \fB_upk_svcinfo\fP"
.br
.RI "\fIsee definition in *protocol_fields.h. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBUPK_MAX_STRING_LEN\fP   2048"
.br
.RI "\fIlongest allowable string (other than paths). \fP"
.ti -1c
.RI "#define \fBUPK_MAX_PATH_LEN\fP   8192"
.br
.RI "\fIlongest allowable path. \fP"
.ti -1c
.RI "#define \fBUPKLIST_METANODE\fP(TYPE, NAME)   struct { TYPE * head; TYPE * tail; TYPE * prevp; TYPE * nextp; TYPE * tempp; TYPE * thisp; \fBuint32_t\fP count; void *userdata; void (*userdata_free_func)(void *); } * NAME"
.br
.RI "\fIdefinition of metanode for a given type. \fP"
.ti -1c
.RI "#define \fBUPKLIST_INIT\fP(TYPE, NAME)"
.br
.ti -1c
.RI "#define \fB_UPKLIST_NEWNODE\fP(NAME)   NAME->tempp = calloc(1,sizeof(*(NAME->tempp)))"
.br
.ti -1c
.RI "#define \fBUPKLIST_APPEND_THIS\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_APPEND\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_PREPEND_THIS\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_PREPEND\fP(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKLIST_NEXTNODE\fP(NAME)   ( (NAME->thisp) ? NAME->thisp->next : NULL )"
.br
.ti -1c
.RI "#define \fB_UPKLIST_FOREACH_CONTINUE\fP(NAME)   NAME->tempp = NULL, NAME->prevp = NAME->thisp, NAME->thisp = NAME->nextp, NAME->nextp = _UPKLIST_NEXTNODE(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKLIST_FOREACH_INIT\fP(NAME)   NAME->tempp = NULL, NAME->prevp = NULL, NAME->thisp = NAME->head, NAME->nextp = _UPKLIST_NEXTNODE(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_FOREACH\fP(NAME)   for( _UPKLIST_FOREACH_INIT(NAME); NAME->thisp != NULL; _UPKLIST_FOREACH_CONTINUE(NAME) )"
.br
.ti -1c
.RI "#define \fBUPKLIST_HEAD\fP(NAME)   do { UPKLIST_FOREACH(NAME) { break; } } while(0)"
.br
.ti -1c
.RI "#define \fBUPKLIST_SWAP\fP(NAME, A, APREV, B, BPREV)"
.br
.ti -1c
.RI "#define \fBUPKLIST_UNLINK\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKLIST_FREE\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_METANODE\fP(TYPE, NAME)   struct { TYPE * head; TYPE * tail; TYPE * prevp; TYPE * nextp; TYPE * tempp; TYPE * thisp; \fBuint32_t\fP count; void *userdata; void (*userdata_free_func)(void *); } * NAME"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_NEWNODE\fP(NAME)   NAME->tempp = calloc(1,sizeof(*(NAME->tempp)))"
.br
.ti -1c
.RI "#define \fBUPKDLIST_INIT\fP(TYPE, NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_APPEND_THIS\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_APPEND\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_PREPEND_THIS\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_PREPEND\fP(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_NEXTNODE\fP(NAME)   ( (NAME->thisp) ? NAME->thisp->next : NULL )"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_PREVNODE\fP(NAME)   ( (NAME->thisp) ? NAME->thisp->prev : NULL )"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_FOREACH_CONTINUE\fP(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_FOREACH_INIT\fP(NAME)   NAME->tempp = NULL, NAME->prevp = NULL, NAME->thisp = NAME->head, NAME->nextp = _UPKDLIST_NEXTNODE(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_FOREACH\fP(NAME)   for( _UPKDLIST_FOREACH_INIT(NAME); NAME->thisp != NULL; _UPKDLIST_FOREACH_CONTINUE(NAME) )"
.br
.ti -1c
.RI "#define \fBUPKDLIST_HEAD\fP(NAME)   do { UPKDLIST_FOREACH(NAME) { break; } } while(0)"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_FOREACH_R_CONTINUE\fP(NAME)"
.br
.ti -1c
.RI "#define \fB_UPKDLIST_FOREACH_R_INIT\fP(NAME)   NAME->tempp = NULL, NAME->nextp = NULL, NAME->thisp = NAME->tail, NAME->prevp = _UPKDLIST_PREVNODE(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_FOREACH_REVERSE\fP(NAME)   for( _UPKDLIST_FOREACH_R_INIT(NAME); NAME->thisp != NULL; _UPKDLIST_FOREACH_R_CONTINUE(NAME) )"
.br
.ti -1c
.RI "#define \fBUPKDLIST_TAIL\fP(NAME)   do { UPKDLIST_FOREACH_REVERSE(NAME) { break; } } while(0)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_SWAP\fP(NAME, A, B)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_UNLINK\fP(NAME)"
.br
.ti -1c
.RI "#define \fBUPKDLIST_FREE\fP(NAME)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_upk_svcid\fP \fBupk_svcid_t\fP"
.br
.RI "\fIlinked list of service identifiers. \fP"
.ti -1c
.RI "typedef struct \fB_upk_cust_actscr_list\fP \fBupk_cust_actscr_list_t\fP"
.br
.RI "\fIlinked list of custom action scripts. \fP"
.ti -1c
.RI "typedef struct \fB_upk_stringlist\fP \fBupk_stringlist_t\fP"
.br
.RI "\fIdoubly linked list of strings. For generic things. \fP"
.ti -1c
.RI "typedef struct \fB_upk_svcinfo\fP \fBupk_svcinfo_t\fP"
.br
.RI "\fIsee definition in *protocol_fields.h. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBupk_state_t\fP { \fBUPK_STATE_UNDEFINED\fP, \fBUPK_STATE_RUNNING\fP, \fBUPK_STATE_STOPPED\fP, \fBUPK_STATE_SHUTDOWN\fP, \fBUPK_STATE_UNDEFINED\fP, \fBUPK_STATE_RUNNING\fP, \fBUPK_STATE_STOPPED\fP, \fBUPK_STATE_SHUTDOWN\fP, \fBUPK_STATE_UNDEFINED\fP, \fBUPK_STATE_RUNNING\fP, \fBUPK_STATE_STOPPED\fP, \fBUPK_STATE_SHUTDOWN\fP }"
.br
.RI "\fIrun states to report to clients. \fP"
.ti -1c
.RI "enum \fBupk_signal_t\fP { \fBUPK_SIG_HUP\fP =  1, \fBUPK_SIG_INT\fP =  2, \fBUPK_SIG_QUIT\fP =  3, \fBUPK_SIG_ILL\fP =  4, \fBUPK_SIG_TRAP\fP =  5, \fBUPK_SIG_ABRT\fP =  6, \fBUPK_SIG_BUS\fP =  7, \fBUPK_SIG_FPE\fP =  8, \fBUPK_SIG_KILL\fP =  9, \fBUPK_SIG_USR1\fP =  10, \fBUPK_SIG_SEGV\fP =  11, \fBUPK_SIG_USR2\fP =  12, \fBUPK_SIG_PIPE\fP =  13, \fBUPK_SIG_ALRM\fP =  14, \fBUPK_SIG_TERM\fP =  15, \fBUPK_SIG_STKFLT\fP =  16, \fBUPK_SIG_CHLD\fP =  17, \fBUPK_SIG_CONT\fP =  18, \fBUPK_SIG_STOP\fP =  19, \fBUPK_SIG_TSTP\fP =  20, \fBUPK_SIG_TTIN\fP =  21, \fBUPK_SIG_TTOU\fP =  22, \fBUPK_SIG_URG\fP =  23, \fBUPK_SIG_XCPU\fP =  24, \fBUPK_SIG_XFSZ\fP =  25, \fBUPK_SIG_VTALRM\fP =  26, \fBUPK_SIG_PROF\fP =  27, \fBUPK_SIG_WINCH\fP =  28, \fBUPK_SIG_IO\fP =  29, \fBUPK_SIG_PWR\fP =  30, \fBUPK_SIG_SYS\fP =  31, \fBUPK_SIG_HUP\fP =  1, \fBUPK_SIG_INT\fP =  2, \fBUPK_SIG_QUIT\fP =  3, \fBUPK_SIG_ILL\fP =  4, \fBUPK_SIG_TRAP\fP =  5, \fBUPK_SIG_ABRT\fP =  6, \fBUPK_SIG_BUS\fP =  7, \fBUPK_SIG_FPE\fP =  8, \fBUPK_SIG_KILL\fP =  9, \fBUPK_SIG_USR1\fP =  10, \fBUPK_SIG_SEGV\fP =  11, \fBUPK_SIG_USR2\fP =  12, \fBUPK_SIG_PIPE\fP =  13, \fBUPK_SIG_ALRM\fP =  14, \fBUPK_SIG_TERM\fP =  15, \fBUPK_SIG_STKFLT\fP =  16, \fBUPK_SIG_CHLD\fP =  17, \fBUPK_SIG_CONT\fP =  18, \fBUPK_SIG_STOP\fP =  19, \fBUPK_SIG_TSTP\fP =  20, \fBUPK_SIG_TTIN\fP =  21, \fBUPK_SIG_TTOU\fP =  22, \fBUPK_SIG_URG\fP =  23, \fBUPK_SIG_XCPU\fP =  24, \fBUPK_SIG_XFSZ\fP =  25, \fBUPK_SIG_VTALRM\fP =  26, \fBUPK_SIG_PROF\fP =  27, \fBUPK_SIG_WINCH\fP =  28, \fBUPK_SIG_IO\fP =  29, \fBUPK_SIG_PWR\fP =  30, \fBUPK_SIG_SYS\fP =  31, \fBUPK_SIG_HUP\fP =  1, \fBUPK_SIG_INT\fP =  2, \fBUPK_SIG_QUIT\fP =  3, \fBUPK_SIG_ILL\fP =  4, \fBUPK_SIG_TRAP\fP =  5, \fBUPK_SIG_ABRT\fP =  6, \fBUPK_SIG_BUS\fP =  7, \fBUPK_SIG_FPE\fP =  8, \fBUPK_SIG_KILL\fP =  9, \fBUPK_SIG_USR1\fP =  10, \fBUPK_SIG_SEGV\fP =  11, \fBUPK_SIG_USR2\fP =  12, \fBUPK_SIG_PIPE\fP =  13, \fBUPK_SIG_ALRM\fP =  14, \fBUPK_SIG_TERM\fP =  15, \fBUPK_SIG_STKFLT\fP =  16, \fBUPK_SIG_CHLD\fP =  17, \fBUPK_SIG_CONT\fP =  18, \fBUPK_SIG_STOP\fP =  19, \fBUPK_SIG_TSTP\fP =  20, \fBUPK_SIG_TTIN\fP =  21, \fBUPK_SIG_TTOU\fP =  22, \fBUPK_SIG_URG\fP =  23, \fBUPK_SIG_XCPU\fP =  24, \fBUPK_SIG_XFSZ\fP =  25, \fBUPK_SIG_VTALRM\fP =  26, \fBUPK_SIG_PROF\fP =  27, \fBUPK_SIG_WINCH\fP =  28, \fBUPK_SIG_IO\fP =  29, \fBUPK_SIG_PWR\fP =  30, \fBUPK_SIG_SYS\fP =  31 }"
.br
.RI "\fIsignal names. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "typedef \fBUPKLIST_METANODE\fP (\fBupk_svcid_t\fP, \fB_upk_svcid_meta_p\fP)"
.br
.ti -1c
.RI "typedef \fBUPKLIST_METANODE\fP (\fBupk_cust_actscr_list_t\fP, \fB_upk_cust_actscr_meta_p\fP)"
.br
.ti -1c
.RI "typedef \fBUPKDLIST_METANODE\fP (\fBupk_stringlist_t\fP, \fB_upk_stringlist_meta_p\fP)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "typedef \fBupk_svcid_meta_t\fP"
.br
.ti -1c
.RI "typedef \fBupk_cust_actscr_meta_t\fP"
.br
.ti -1c
.RI "typedef \fBupk_stringlist_meta_t\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
types common throughout libupkeeper. 

Types used commonly, and (ideally) not more suitably defined elsewhere. 
.SH "Define Documentation"
.PP 
.SS "#define _UPKDLIST_FOREACH_CONTINUE(NAME)"\fBValue:\fP
.PP
.nf
NAME->tempp = NULL, NAME->prevp = NAME->thisp, NAME->thisp = NAME->nextp, \
    NAME->nextp = _UPKDLIST_NEXTNODE(NAME), NAME->prevp = _UPKDLIST_PREVNODE(NAME)
.fi
.SS "#define _UPKDLIST_FOREACH_INIT(NAME)   NAME->tempp = NULL, NAME->prevp = NULL, NAME->thisp = NAME->head, NAME->nextp = _UPKDLIST_NEXTNODE(NAME)"
.SS "#define _UPKDLIST_FOREACH_R_CONTINUE(NAME)"\fBValue:\fP
.PP
.nf
NAME->tempp = NULL, NAME->nextp = NAME->thisp, NAME->thisp = NAME->prevp, \
    NAME->prevp = _UPKDLIST_PREVNODE(NAME), NAME->nextp = _UPKDLIST_NEXTNODE(NAME)
.fi
.SS "#define _UPKDLIST_FOREACH_R_INIT(NAME)   NAME->tempp = NULL, NAME->nextp = NULL, NAME->thisp = NAME->tail, NAME->prevp = _UPKDLIST_PREVNODE(NAME)"
.SS "#define _UPKDLIST_NEWNODE(NAME)   NAME->tempp = calloc(1,sizeof(*(NAME->tempp)))"
.SS "#define _UPKDLIST_NEXTNODE(NAME)   ( (NAME->thisp) ? NAME->thisp->next : NULL )"
.SS "#define _UPKDLIST_PREVNODE(NAME)   ( (NAME->thisp) ? NAME->thisp->prev : NULL )"
.SS "#define _UPKLIST_FOREACH_CONTINUE(NAME)   NAME->tempp = NULL, NAME->prevp = NAME->thisp, NAME->thisp = NAME->nextp, NAME->nextp = _UPKLIST_NEXTNODE(NAME)"
.SS "#define _UPKLIST_FOREACH_INIT(NAME)   NAME->tempp = NULL, NAME->prevp = NULL, NAME->thisp = NAME->head, NAME->nextp = _UPKLIST_NEXTNODE(NAME)"
.SS "#define _UPKLIST_NEWNODE(NAME)   NAME->tempp = calloc(1,sizeof(*(NAME->tempp)))"
.SS "#define _UPKLIST_NEXTNODE(NAME)   ( (NAME->thisp) ? NAME->thisp->next : NULL )"
.SS "#define UPK_MAX_PATH_LEN   8192"
.PP
longest allowable path. 
.PP
Referenced by buddy_sock_path(), create_buddy(), create_buddy_statedir(), handle_buddies(), kill_buddy(), lookup_buddy_from_path(), reload_buddy_svc(), remove_buddy_statedir(), spawn_buddy(), start_buddy_svc(), stop_buddy_svc(), upk_ctrl_attach_db(), upk_ctrl_init(), upk_ctrl_init_db(), upk_load_runtime_services(), upk_rm_rf(), and upk_svcconf_string_handler().
.SS "#define UPK_MAX_STRING_LEN   2048"
.PP
longest allowable string (other than paths). 
.PP
Referenced by buddy_init_paths(), ctrl_req_action_handler(), ctrl_req_preamble_handler(), upk_clientid(), upk_concat_svcid(), upk_config_loadfile(), upk_create_req_preamble(), upk_ctrl_attach_db(), upk_ctrl_load_config(), upk_ctrlconf_string_handler(), upk_db_add_new_service(), upk_db_gen_uuid(), upk_db_get_single_text(), upk_db_get_table_id(), upk_db_insert_cfg(), upk_db_svc_uuid_lookup(), upk_db_try_insert(), upk_db_try_update(), upk_db_upsert(), upk_db_upsert_options(), upk_json_append_string(), upk_json_output_array_handler(), upk_json_output_object_handler(), upk_mkdir_p(), upk_output_json_string(), upk_svc_desc_to_json_obj(), upk_svcconf_customaction_array_appender(), upk_svcconf_string_handler(), upk_svcconf_svcid_array_appender(), upk_svclist_to_json_obj(), and v0_create_repl_svcinfo().
.SS "#define UPKDLIST_APPEND(NAME)"\fBValue:\fP
.PP
.nf
NAME->thisp = NAME->tail; \
    NAME->prevp = (NAME->thisp) ? NAME->thisp->prev : NAME->head; \
    UPKDLIST_APPEND_THIS(NAME)
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKDLIST_APPEND_THIS(NAME)"\fBValue:\fP
.PP
.nf
_UPKDLIST_NEWNODE(NAME); \
    NAME->tempp->next = NAME->nextp; \
    if(NAME->thisp) { NAME->thisp->next = NAME->tempp; NAME->tempp->prev = NAME->thisp; } \
    if(! NAME->nextp ) { NAME->tail = NAME->tempp; } \
    if(! NAME->prevp && NAME->count == 0 ) { NAME->head = NAME->tempp; } \
    ++NAME->count; \
    NAME->thisp = NAME->tempp;
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKDLIST_FOREACH(NAME)   for( _UPKDLIST_FOREACH_INIT(NAME); NAME->thisp != NULL; _UPKDLIST_FOREACH_CONTINUE(NAME) )"
.PP
Referenced by START_TEST().
.SS "#define UPKDLIST_FOREACH_REVERSE(NAME)   for( _UPKDLIST_FOREACH_R_INIT(NAME); NAME->thisp != NULL; _UPKDLIST_FOREACH_R_CONTINUE(NAME) )"
.PP
Referenced by START_TEST().
.SS "#define UPKDLIST_FREE(NAME)"\fBValue:\fP
.PP
.nf
do { \
        if(NAME) { \
            UPKDLIST_FOREACH(NAME) { \
                UPKDLIST_UNLINK(NAME); \
            }\
            if(NAME->userdata && NAME->userdata_free_func) { NAME->userdata_free_func(NAME->userdata); } \
            free(NAME); \
        } \
    } while(0)
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKDLIST_HEAD(NAME)   do { UPKDLIST_FOREACH(NAME) { break; } } while(0)"
.SS "#define UPKDLIST_INIT(TYPE, NAME)"\fBValue:\fP
.PP
.nf
UPKDLIST_METANODE(TYPE, NAME) = NULL; \
    NAME = calloc(1, sizeof(*NAME)); \
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKDLIST_METANODE(TYPE, NAME)   struct { TYPE * head; TYPE * tail; TYPE * prevp; TYPE * nextp; TYPE * tempp; TYPE * thisp; \fBuint32_t\fP count; void *userdata; void (*userdata_free_func)(void *); } * NAME"
.SS "#define UPKDLIST_PREPEND(NAME)"\fBValue:\fP
.PP
.nf
NAME->prevp = NULL; \
    NAME->thisp = NAME->head; \
    UPKDLIST_PREPEND_THIS(NAME)
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKDLIST_PREPEND_THIS(NAME)"\fBValue:\fP
.PP
.nf
_UPKDLIST_NEWNODE(NAME); \
    NAME->tempp->next = NAME->thisp; \
    if(NAME->thisp) {  NAME->tempp->prev = NAME->thisp->prev; NAME->thisp->prev = NAME->tempp; } \
    if(! NAME->nextp ) { NAME->tail = NAME->tempp; } \
    if(! NAME->prevp ) { NAME->head = NAME->tempp; } else { NAME->prevp->next = NAME->tempp; } \
    ++NAME->count; \
    NAME->thisp = NAME->tempp
.fi
.SS "#define UPKDLIST_SWAP(NAME, A, B)"\fBValue:\fP
.PP
.nf
NAME->tempp = calloc(1,sizeof(*NAME->tempp)); \
    A->prev->next = B; \
    B->prev->next = A; \
    NAME->tempp->next = A->next; \
    NAME->tempp->prev = A->prev; \
    A->next = B->next; \
    A->prev = B->prev; \
    B->next = NAME->tempp->next; \
    B->prev = NAME->tempp->prev; \
    free(NAME->tempp); NAME->tempp = NULL
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKDLIST_TAIL(NAME)   do { UPKDLIST_FOREACH_REVERSE(NAME) { break; } } while(0)"
.SS "#define UPKDLIST_UNLINK(NAME)"\fBValue:\fP
.PP
.nf
do{ \
        if(NAME->thisp) { \
            if(! NAME->prevp ) { NAME->head = NAME->nextp; } else { NAME->prevp->next = NAME->nextp; } \
            if(! NAME->nextp ) { NAME->tail = NAME->prevp; } else { NAME->nextp->prev = NAME->prevp; }  \
            free(NAME->thisp); NAME->thisp = NULL; \
            --NAME->count; \
        } \
    } while(0)
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKLIST_APPEND(NAME)"\fBValue:\fP
.PP
.nf
NAME->thisp = NAME->tail; \
    NAME->prevp = (NAME->prevp) ? NAME->prevp : NAME->head; \
    UPKLIST_APPEND_THIS(NAME); \
    NAME->prevp = NULL
.fi
.PP
Referenced by sa_sigaction_func(), START_TEST(), upk_json_serialize_svc_config(), upk_load_runtime_services(), upk_net_add_socket_handle(), upk_overlay_ctrlconf_values(), upk_overlay_svcconf_values(), upk_queue_packet(), upk_svcconf_customaction_array_appender(), upk_svcconf_object_handler(), and upk_svcconf_svcid_array_appender().
.SS "#define UPKLIST_APPEND_THIS(NAME)"\fBValue:\fP
.PP
.nf
_UPKLIST_NEWNODE(NAME); \
    NAME->tempp->next = NAME->nextp; \
    if(! NAME->nextp ) { NAME->tail = NAME->tempp; } \
    if(! NAME->prevp && NAME->count == 0 ) { NAME->head = NAME->tempp; } \
    if(NAME->thisp) { NAME->thisp->next = NAME->tempp; } \
    ++NAME->count; \
    NAME->thisp = NAME->tempp;
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKLIST_FOREACH(NAME)   for( _UPKLIST_FOREACH_INIT(NAME); NAME->thisp != NULL; _UPKLIST_FOREACH_CONTINUE(NAME) )"
.PP
Referenced by create_buddy_statedir(), ctrl_req_action_handler(), lookup_buddy_from_path(), main(), remove_buddy_statedir(), START_TEST(), upk_build_fd_sets(), upk_ctrl_init(), upk_db_upsert_options(), upk_json_stack_pop(), upk_load_runtime_services(), upk_mkdir_p(), upk_net_event_dispatcher(), upk_net_flush_closed_sockets(), upk_overlay_ctrlconf_values(), upk_overlay_svcconf_values(), upk_svc_desc_free(), upk_svc_desc_to_json_obj(), upk_svclist_free(), and upk_svclist_to_json_obj().
.SS "#define UPKLIST_FREE(NAME)"\fBValue:\fP
.PP
.nf
do { \
        if(NAME) { \
            UPKLIST_FOREACH(NAME) { \
                UPKLIST_UNLINK(NAME); \
            }\
            if(NAME->userdata && NAME->userdata_free_func) { NAME->userdata_free_func(NAME->userdata); } \
            free(NAME); \
        } \
    } while(0)
.fi
.PP
Referenced by ctrl_exit_cleanup(), START_TEST(), upk_clnet_ctrl_disconnect(), upk_ctrlconf_pack(), upk_json_obj_serializer(), upk_json_serialize_svc_config(), upk_load_runtime_services(), upk_mkdir_p(), upk_net_flush_closed_sockets(), upk_overlay_ctrlconf_values(), upk_partitioned_userdata_free(), upk_svc_desc_free(), upk_svcconf_pack(), and upk_svclist_free().
.SS "#define UPKLIST_HEAD(NAME)   do { UPKLIST_FOREACH(NAME) { break; } } while(0)"
.PP
Referenced by handle_signals(), upk_callback_stack_pop(), upk_clnet_ctrl_connect(), upk_clnet_req_disconnect(), and upk_clnet_serial_request().
.SS "#define UPKLIST_INIT(TYPE, NAME)"\fBValue:\fP
.PP
.nf
UPKLIST_METANODE(TYPE, NAME) = NULL; \
    NAME = calloc(1, sizeof(*NAME))
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKLIST_METANODE(TYPE, NAME)   struct { TYPE * head; TYPE * tail; TYPE * prevp; TYPE * nextp; TYPE * tempp; TYPE * thisp; \fBuint32_t\fP count; void *userdata; void (*userdata_free_func)(void *); } * NAME"
.PP
definition of metanode for a given type. this macro contains a pionter; so if you want to use it to create a typedef, it would look something like:
.PP
\fBUPKLIST_METANODE(my_listtype_t, listtype_metanode_p)\fP, listtype_metanode_t;
.PP
or similar. 
.SS "#define UPKLIST_PREPEND(NAME)"\fBValue:\fP
.PP
.nf
NAME->prevp = NULL; \
    NAME->thisp = NAME->head; \
    UPKLIST_PREPEND_THIS(NAME)
.fi
.PP
Referenced by init_callback_handlers(), START_TEST(), upk_callback_stack_push(), upk_json_stack_push(), and upk_mkdir_p().
.SS "#define UPKLIST_PREPEND_THIS(NAME)"\fBValue:\fP
.PP
.nf
_UPKLIST_NEWNODE(NAME); \
    NAME->tempp->next = NAME->thisp; \
    if(! NAME->nextp ) { NAME->tail = NAME->tempp; } \
    if(! NAME->prevp ) { NAME->head = NAME->tempp; } else { NAME->prevp->next = NAME->tempp; } \
    ++NAME->count; \
    NAME->thisp = NAME->tempp
.fi
.SS "#define UPKLIST_SWAP(NAME, A, APREV, B, BPREV)"\fBValue:\fP
.PP
.nf
NAME->tempp = calloc(1,sizeof(*NAME->tempp)); \
    APREV->next = B; \
    BPREV->next = A; \
    NAME->tempp->next = A->next; \
    A->next = B->next; \
    B->next = NAME->tempp->next; \
    free(NAME->tempp); NAME->tempp = NULL
.fi
.PP
Referenced by START_TEST().
.SS "#define UPKLIST_UNLINK(NAME)"\fBValue:\fP
.PP
.nf
do { \
        if(NAME->thisp) { \
            if(! NAME->prevp ) { NAME->head = NAME->nextp; } else { NAME->prevp->next = NAME->nextp; } \
            if(! NAME->nextp ) { NAME->tail = NAME->prevp; } \
            free(NAME->thisp); NAME->thisp = NULL; \
            --NAME->count; \
        } \
    } while(0)
.fi
.PP
Referenced by handle_signals(), START_TEST(), upk_callback_stack_pop(), upk_json_stack_pop(), upk_net_flush_closed_sockets(), upk_overlay_svcconf_values(), upk_svc_desc_free(), and upk_write_packets().
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_upk_cust_actscr_list\fP \fBupk_cust_actscr_list_t\fP"
.PP
linked list of custom action scripts. 
.SS "typedef struct \fB_upk_stringlist\fP \fBupk_stringlist_t\fP"
.PP
doubly linked list of strings. For generic things. 
.SS "typedef struct \fB_upk_svcid\fP \fBupk_svcid_t\fP"
.PP
linked list of service identifiers. 
.SS "typedef struct \fB_upk_svcinfo\fP  \fBupk_svcinfo_t\fP"
.PP
see definition in *protocol_fields.h. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBupk_signal_t\fP"
.PP
signal names. List of signal names, so that the platform's signal numbering is no longer significant for data storage, or communication with controller 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIUPK_SIG_HUP \fP\fP
.TP
\fB\fIUPK_SIG_INT \fP\fP
.TP
\fB\fIUPK_SIG_QUIT \fP\fP
.TP
\fB\fIUPK_SIG_ILL \fP\fP
.TP
\fB\fIUPK_SIG_TRAP \fP\fP
.TP
\fB\fIUPK_SIG_ABRT \fP\fP
.TP
\fB\fIUPK_SIG_BUS \fP\fP
.TP
\fB\fIUPK_SIG_FPE \fP\fP
.TP
\fB\fIUPK_SIG_KILL \fP\fP
.TP
\fB\fIUPK_SIG_USR1 \fP\fP
.TP
\fB\fIUPK_SIG_SEGV \fP\fP
.TP
\fB\fIUPK_SIG_USR2 \fP\fP
.TP
\fB\fIUPK_SIG_PIPE \fP\fP
.TP
\fB\fIUPK_SIG_ALRM \fP\fP
.TP
\fB\fIUPK_SIG_TERM \fP\fP
.TP
\fB\fIUPK_SIG_STKFLT \fP\fP
.TP
\fB\fIUPK_SIG_CHLD \fP\fP
.TP
\fB\fIUPK_SIG_CONT \fP\fP
.TP
\fB\fIUPK_SIG_STOP \fP\fP
.TP
\fB\fIUPK_SIG_TSTP \fP\fP
.TP
\fB\fIUPK_SIG_TTIN \fP\fP
.TP
\fB\fIUPK_SIG_TTOU \fP\fP
.TP
\fB\fIUPK_SIG_URG \fP\fP
.TP
\fB\fIUPK_SIG_XCPU \fP\fP
.TP
\fB\fIUPK_SIG_XFSZ \fP\fP
.TP
\fB\fIUPK_SIG_VTALRM \fP\fP
.TP
\fB\fIUPK_SIG_PROF \fP\fP
.TP
\fB\fIUPK_SIG_WINCH \fP\fP
.TP
\fB\fIUPK_SIG_IO \fP\fP
.TP
\fB\fIUPK_SIG_PWR \fP\fP
.TP
\fB\fIUPK_SIG_SYS \fP\fP
.TP
\fB\fIUPK_SIG_HUP \fP\fP
hup 
.TP
\fB\fIUPK_SIG_INT \fP\fP
int 
.TP
\fB\fIUPK_SIG_QUIT \fP\fP
quit 
.TP
\fB\fIUPK_SIG_ILL \fP\fP
ill 
.TP
\fB\fIUPK_SIG_TRAP \fP\fP
trap 
.TP
\fB\fIUPK_SIG_ABRT \fP\fP
abrt 
.TP
\fB\fIUPK_SIG_BUS \fP\fP
bus 
.TP
\fB\fIUPK_SIG_FPE \fP\fP
fpe 
.TP
\fB\fIUPK_SIG_KILL \fP\fP
kill 
.TP
\fB\fIUPK_SIG_USR1 \fP\fP
usr1 
.TP
\fB\fIUPK_SIG_SEGV \fP\fP
segv 
.TP
\fB\fIUPK_SIG_USR2 \fP\fP
usr2 
.TP
\fB\fIUPK_SIG_PIPE \fP\fP
pipe 
.TP
\fB\fIUPK_SIG_ALRM \fP\fP
alrm 
.TP
\fB\fIUPK_SIG_TERM \fP\fP
term 
.TP
\fB\fIUPK_SIG_STKFLT \fP\fP
stkflt 
.TP
\fB\fIUPK_SIG_CHLD \fP\fP
chld 
.TP
\fB\fIUPK_SIG_CONT \fP\fP
cont 
.TP
\fB\fIUPK_SIG_STOP \fP\fP
stop 
.TP
\fB\fIUPK_SIG_TSTP \fP\fP
tstp 
.TP
\fB\fIUPK_SIG_TTIN \fP\fP
ttin 
.TP
\fB\fIUPK_SIG_TTOU \fP\fP
ttou 
.TP
\fB\fIUPK_SIG_URG \fP\fP
urg 
.TP
\fB\fIUPK_SIG_XCPU \fP\fP
xcpu 
.TP
\fB\fIUPK_SIG_XFSZ \fP\fP
xfsz 
.TP
\fB\fIUPK_SIG_VTALRM \fP\fP
vtalrm 
.TP
\fB\fIUPK_SIG_PROF \fP\fP
prof 
.TP
\fB\fIUPK_SIG_WINCH \fP\fP
winch 
.TP
\fB\fIUPK_SIG_IO \fP\fP
io 
.TP
\fB\fIUPK_SIG_PWR \fP\fP
pwr 
.TP
\fB\fIUPK_SIG_SYS \fP\fP
sys 
.TP
\fB\fIUPK_SIG_HUP \fP\fP
.TP
\fB\fIUPK_SIG_INT \fP\fP
.TP
\fB\fIUPK_SIG_QUIT \fP\fP
.TP
\fB\fIUPK_SIG_ILL \fP\fP
.TP
\fB\fIUPK_SIG_TRAP \fP\fP
.TP
\fB\fIUPK_SIG_ABRT \fP\fP
.TP
\fB\fIUPK_SIG_BUS \fP\fP
.TP
\fB\fIUPK_SIG_FPE \fP\fP
.TP
\fB\fIUPK_SIG_KILL \fP\fP
.TP
\fB\fIUPK_SIG_USR1 \fP\fP
.TP
\fB\fIUPK_SIG_SEGV \fP\fP
.TP
\fB\fIUPK_SIG_USR2 \fP\fP
.TP
\fB\fIUPK_SIG_PIPE \fP\fP
.TP
\fB\fIUPK_SIG_ALRM \fP\fP
.TP
\fB\fIUPK_SIG_TERM \fP\fP
.TP
\fB\fIUPK_SIG_STKFLT \fP\fP
.TP
\fB\fIUPK_SIG_CHLD \fP\fP
.TP
\fB\fIUPK_SIG_CONT \fP\fP
.TP
\fB\fIUPK_SIG_STOP \fP\fP
.TP
\fB\fIUPK_SIG_TSTP \fP\fP
.TP
\fB\fIUPK_SIG_TTIN \fP\fP
.TP
\fB\fIUPK_SIG_TTOU \fP\fP
.TP
\fB\fIUPK_SIG_URG \fP\fP
.TP
\fB\fIUPK_SIG_XCPU \fP\fP
.TP
\fB\fIUPK_SIG_XFSZ \fP\fP
.TP
\fB\fIUPK_SIG_VTALRM \fP\fP
.TP
\fB\fIUPK_SIG_PROF \fP\fP
.TP
\fB\fIUPK_SIG_WINCH \fP\fP
.TP
\fB\fIUPK_SIG_IO \fP\fP
.TP
\fB\fIUPK_SIG_PWR \fP\fP
.TP
\fB\fIUPK_SIG_SYS \fP\fP

.SS "enum \fBupk_state_t\fP"
.PP
run states to report to clients. The current state of a monitored service 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIUPK_STATE_UNDEFINED \fP\fP
.TP
\fB\fIUPK_STATE_RUNNING \fP\fP
.TP
\fB\fIUPK_STATE_STOPPED \fP\fP
.TP
\fB\fIUPK_STATE_SHUTDOWN \fP\fP
.TP
\fB\fIUPK_STATE_UNDEFINED \fP\fP
unknown/undefined; probably an error 
.TP
\fB\fIUPK_STATE_RUNNING \fP\fP
the service is running 
.TP
\fB\fIUPK_STATE_STOPPED \fP\fP
the service is stopped 
.TP
\fB\fIUPK_STATE_SHUTDOWN \fP\fP
the service is stopped, and its buddy is not running 
.TP
\fB\fIUPK_STATE_UNDEFINED \fP\fP
.TP
\fB\fIUPK_STATE_RUNNING \fP\fP
.TP
\fB\fIUPK_STATE_STOPPED \fP\fP
.TP
\fB\fIUPK_STATE_SHUTDOWN \fP\fP

.SH "Function Documentation"
.PP 
.SS "typedef UPKDLIST_METANODE (\fBupk_stringlist_t\fP, \fB_upk_stringlist_meta_p\fP)"
.SS "typedef UPKLIST_METANODE (\fBupk_svcid_t\fP, \fB_upk_svcid_meta_p\fP)"
.SS "typedef UPKLIST_METANODE (\fBupk_cust_actscr_list_t\fP, \fB_upk_cust_actscr_meta_p\fP)"
.SH "Variable Documentation"
.PP 
.SS "typedef \fBupk_cust_actscr_meta_t\fP"
.SS "typedef \fBupk_stringlist_meta_t\fP"
.SS "typedef \fBupk_svcid_meta_t\fP"
.SH "Author"
.PP 
Generated automatically by Doxygen for upkeeper from the source code.
