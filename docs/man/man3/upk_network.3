.TH "Upk_network" 3 "Tue Nov 1 2011" "Version 1" "upkeeper" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Upk_network \- 
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_upk_netmsg_queue\fP"
.br
.RI "\fIthis is a tailq for network message queuing \fP"
.ti -1c
.RI "struct \fB_upk_net_cb_stk\fP"
.br
.ti -1c
.RI "struct \fB_upk_net_gstate\fP"
.br
.ti -1c
.RI "struct \fB_upklist_userdata_state_partition\fP"
.br
.ti -1c
.RI "struct \fB_upk_conn_handle\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_upk_conn_handle\fP \fBupk_conn_handle_t\fP"
.br
.ti -1c
.RI "typedef void(* \fBupk_net_callback_t\fP )(\fBupk_conn_handle_meta_t\fP *handles, \fBupk_payload_t\fP *msg)"
.br
.RI "\fItypedef for callback functions. \fP"
.ti -1c
.RI "typedef struct \fB_upk_netmsg_queue\fP \fBupk_netmsg_queue_t\fP"
.br
.RI "\fIthis is a tailq for network message queuing \fP"
.ti -1c
.RI "typedef struct \fB_upk_net_cb_stk\fP \fBupk_net_cb_stk_t\fP"
.br
.ti -1c
.RI "typedef struct \fB_upk_net_gstate\fP \fBupk_net_gstate_t\fP"
.br
.ti -1c
.RI "typedef struct \fB_upklist_userdata_state_partition\fP \fBupklist_userdata_state_partition_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBupk_domain_socket_connect\fP (const char *sockpath)"
.br
.RI "\fImake unix-domain socket connection. \fP"
.ti -1c
.RI "void \fBupk_read_packets\fP (\fBupk_conn_handle_meta_t\fP *handles)"
.br
.RI "\fIretry socket connection, pausing between each retry. \fP"
.ti -1c
.RI "void \fBupk_queue_packet\fP (\fBupk_conn_handle_t\fP *handle, \fBupk_packet_t\fP *pkt, \fBupk_net_callback_t\fP after_write_callback, \fBupk_net_callback_t\fP set_after_read_callback)"
.br
.RI "\fIqueue a packet to send, will be sent via upk_write_packet. \fP"
.ti -1c
.RI "void \fBupk_write_packets\fP (\fBupk_conn_handle_meta_t\fP *handles)"
.br
.RI "\fIwrite packets from queue async and nonblocking. \fP"
.ti -1c
.RI "void \fBupk_disconnect_handle\fP (\fBupk_conn_handle_meta_t\fP *handles)"
.br
.RI "\fIclose the connection on a given handle and remove the handle from the list of connection handles. \fP"
.ti -1c
.RI "void \fBupk_net_add_socket_handle\fP (\fBupk_conn_handle_meta_t\fP *handles, int fd, \fBupk_net_callback_t\fP pkt_callback)"
.br
.ti -1c
.RI "void \fBupk_net_event_dispatcher\fP (\fBupk_conn_handle_meta_t\fP *handles, double poll_ival)"
.br
.ti -1c
.RI "void \fBupk_net_flush_closed_sockets\fP (\fBupk_conn_handle_meta_t\fP *handles)"
.br
.ti -1c
.RI "int \fBupk_net_block_until_msg\fP (\fBupk_conn_handle_meta_t\fP *handles, double poll_ival, struct timeval *\fBtimeout\fP)"
.br
.ti -1c
.RI "\fBupk_conn_handle_meta_t\fP * \fBupk_net_conn_handle_init\fP (void *userdata, void(*userdata_free_func)(void *ptr))"
.br
.ti -1c
.RI "void \fBupk_net_shutdown_callback\fP (\fBupk_conn_handle_meta_t\fP *handles, \fBupk_payload_t\fP *msg)"
.br
.ti -1c
.RI "typedef \fBUPKLIST_METANODE\fP (\fBupk_conn_handle_t\fP, upk_conn_handle_meta_p)"
.br
.ti -1c
.RI "typedef \fBUPKLIST_METANODE\fP (\fBupk_netmsg_queue_t\fP, upk_netmsg_queue_meta_p)"
.br
.ti -1c
.RI "typedef \fBUPKLIST_METANODE\fP (\fBupk_net_cb_stk_t\fP, upk_net_cb_stk_meta_p)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "typedef \fBupk_conn_handle_meta_t\fP"
.br
.ti -1c
.RI "typedef \fBupk_netmsg_queue_meta_t\fP"
.br
.ti -1c
.RI "typedef \fBupk_net_cb_stk_meta_t\fP"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_upk_conn_handle\fP \fBupk_conn_handle_t\fP"
.SS "typedef void(* \fBupk_net_callback_t\fP)(\fBupk_conn_handle_meta_t\fP *handles, \fBupk_payload_t\fP *msg)"
.PP
typedef for callback functions. \fBParameters:\fP
.RS 4
\fIhandles\fP - the handle list, where thisp is the handle that generated the event for the callback. 
.br
\fIdata\fP - used to pass data you specify to the callbacks. 
.br
\fImsg\fP - the deserialized message. 
.RE
.PP

.SS "typedef struct \fB_upk_net_cb_stk\fP \fBupk_net_cb_stk_t\fP"
.SS "typedef struct \fB_upk_net_gstate\fP \fBupk_net_gstate_t\fP"
.SS "typedef struct \fB_upk_netmsg_queue\fP \fBupk_netmsg_queue_t\fP"
.PP
this is a tailq for network message queuing 
.SS "typedef struct \fB_upklist_userdata_state_partition\fP \fBupklist_userdata_state_partition_t\fP"
.SH "Function Documentation"
.PP 
.SS "void upk_disconnect_handle (\fBupk_conn_handle_meta_t\fP *handles)"
.PP
close the connection on a given handle and remove the handle from the list of connection handles. 
.PP
Referenced by upk_clnet_req_disconnect(), upk_net_event_dispatcher(), upk_net_shutdown_callback(), upk_read_packets(), and upk_write_packets().
.SS "int upk_domain_socket_connect (const char *sockpath)"
.PP
make unix-domain socket connection. \fBParameters:\fP
.RS 4
\fIsockpath\fP the path to the socket to connect to (e.g. the controller socket) 
.RE
.PP
\fBReturns:\fP
.RS 4
the file descriptor of the resulting connection 
.PP
-2 unable to connect, check errno 
.RE
.PP

.PP
Referenced by upk_clnet_ctrl_connect().
.SS "void upk_net_add_socket_handle (\fBupk_conn_handle_meta_t\fP *handles, intfd, \fBupk_net_callback_t\fPpkt_callback)"
.PP
References sockopts, upk_net_get_gstate(), upk_net_get_userdata(), and UPKLIST_APPEND.
.PP
Referenced by accept_conn(), main(), and upk_clnet_ctrl_connect().
.SS "int upk_net_block_until_msg (\fBupk_conn_handle_meta_t\fP *handles, doublepoll_ival, struct timeval *timeout)"
.PP
References _upk_conn_handle::fd, _upk_conn_handle::last_pkt_data, _upk_payload::type, and upk_net_event_dispatcher().
.PP
Referenced by upk_clnet_serial_request().
.SS "\fBupk_conn_handle_meta_t\fP* upk_net_conn_handle_init (void *userdata, void(*)(void *ptr)userdata_free_func)"
.PP
References _upklist_userdata_state_partition::gstate, upk_conn_handle_meta_t, upk_partitioned_userdata_free(), _upklist_userdata_state_partition::userdata, and _upklist_userdata_state_partition::userdata_free_func.
.PP
Referenced by event_loop(), main(), and upk_clnet_ctrl_connect().
.SS "void upk_net_event_dispatcher (\fBupk_conn_handle_meta_t\fP *handles, doublepoll_ival)"
.PP
References _upk_net_gstate::callback_stack, _upk_net_gstate::pending_writeq, upk_build_fd_sets(), upk_disconnect_handle(), upk_double_to_timeval(), upk_net_cb_stk_meta_t, upk_net_get_gstate(), upk_read_packets(), upk_write_packets(), and UPKLIST_FOREACH.
.PP
Referenced by event_loop(), main(), and upk_net_block_until_msg().
.SS "void upk_net_flush_closed_sockets (\fBupk_conn_handle_meta_t\fP *handles)"
.PP
References UPKLIST_FOREACH, and UPKLIST_UNLINK.
.PP
Referenced by event_loop(), upk_clnet_req_disconnect(), and upk_clnet_serial_request().
.SS "void upk_net_shutdown_callback (\fBupk_conn_handle_meta_t\fP *handles, \fBupk_payload_t\fP *msg)"
.PP
References upk_disconnect_handle().
.PP
Referenced by controller_packet_callback().
.SS "void upk_queue_packet (\fBupk_conn_handle_t\fP *handle, \fBupk_packet_t\fP *pkt, \fBupk_net_callback_t\fPafter_write_callback, \fBupk_net_callback_t\fPset_after_read_callback)"
.PP
queue a packet to send, will be sent via upk_write_packet. Queue a packet for a handle 
.PP
References _upk_netmsg_queue::after_write_callback, _upk_conn_handle::gstate, _upk_netmsg_queue::msg, _upk_netmsg_queue::msg_len, upk_packet_t::payload_len, _upk_net_gstate::pending_writeq, _upk_netmsg_queue::set_after_read_callback, UPK_PACKET_FOOTER_LEN, UPK_PACKET_HEADER_LEN, upk_serialize_packet(), UPKLIST_APPEND, and _upk_conn_handle::writeq.
.PP
Referenced by controller_packet_callback(), main(), and upk_clnet_serial_request().
.SS "void upk_read_packets (\fBupk_conn_handle_meta_t\fP *handles)"
.PP
retry socket connection, pausing between each retry. \fBParameters:\fP
.RS 4
\fIretries\fP number of times to retry. 
.br
\fIsockpath\fP path to the socket to connect to (e.g. the controller socket).
.RE
.PP
\fBReturns:\fP
.RS 4
the file descriptor of the resulting connection 
.PP
-2 unable to connect, check errno non-blocking read a packet off the 'wire'.
.RE
.PP
After an entire packet has been recieved, will call the appropriate callback for the packet type. 
.PP
References _upk_conn_handle::fd, _upk_conn_handle::n_hdr_bytes_read, _upk_conn_handle::n_remaining_read, _upk_conn_handle::readbuf, upk_call_received_packet_callbacks(), upk_debug1, upk_deserialize_packet(), upk_disconnect_handle(), upk_error, UPK_MAX_PACKET_SIZE, UPK_MAX_SUPPORTED_PROTO, UPK_MIN_SUPPORTED_PROTO, UPK_PACKET_FOOTER_LEN, UPK_PACKET_HEADER_LEN, and upk_pkt_free().
.PP
Referenced by upk_net_event_dispatcher().
.SS "void upk_write_packets (\fBupk_conn_handle_meta_t\fP *handles)"
.PP
write packets from queue async and nonblocking. 
.PP
References _upk_conn_handle::after_read_callback, _upk_netmsg_queue::after_write_callback, _upk_conn_handle::fd, _upk_netmsg_queue::msg, _upk_netmsg_queue::msg_len, _upk_netmsg_queue::n_bytes_written, _upk_net_gstate::pending_writeq, _upk_netmsg_queue::set_after_read_callback, upk_disconnect_handle(), upk_net_get_gstate(), UPKLIST_UNLINK, and _upk_conn_handle::writeq.
.PP
Referenced by upk_net_event_dispatcher().
.SS "typedef UPKLIST_METANODE (\fBupk_conn_handle_t\fP, upk_conn_handle_meta_p)"
.SS "typedef UPKLIST_METANODE (\fBupk_netmsg_queue_t\fP, upk_netmsg_queue_meta_p)"
.SS "typedef UPKLIST_METANODE (\fBupk_net_cb_stk_t\fP, upk_net_cb_stk_meta_p)"
.SH "Variable Documentation"
.PP 
.SS "typedef \fBupk_conn_handle_meta_t\fP"
.PP
Referenced by event_loop(), main(), upk_clnet_ctrl_connect(), and upk_net_conn_handle_init().
.SS "typedef \fBupk_net_cb_stk_meta_t\fP"
.PP
Referenced by upk_call_received_packet_callbacks(), and upk_net_event_dispatcher().
.SS "typedef \fBupk_netmsg_queue_meta_t\fP"
.SH "Author"
.PP 
Generated automatically by Doxygen for upkeeper from the source code.
